{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/transparent/TransparentUpgradeableProxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967Proxy.sol\";\n\n/**\n * @dev This contract implements a proxy that is upgradeable by an admin.\n *\n * To avoid https://medium.com/nomic-labs-blog/malicious-backdoors-in-ethereum-proxies-62629adf3357[proxy selector\n * clashing], which can potentially be used in an attack, this contract uses the\n * https://blog.openzeppelin.com/the-transparent-proxy-pattern/[transparent proxy pattern]. This pattern implies two\n * things that go hand in hand:\n *\n * 1. If any account other than the admin calls the proxy, the call will be forwarded to the implementation, even if\n * that call matches one of the admin functions exposed by the proxy itself.\n * 2. If the admin calls the proxy, it can access the admin functions, but its calls will never be forwarded to the\n * implementation. If the admin tries to call a function on the implementation it will fail with an error that says\n * \"admin cannot fallback to proxy target\".\n *\n * These properties mean that the admin account can only be used for admin actions like upgrading the proxy or changing\n * the admin, so it's best if it's a dedicated account that is not used for anything else. This will avoid headaches due\n * to sudden errors when trying to call a function from the proxy implementation.\n *\n * Our recommendation is for the dedicated account to be an instance of the {ProxyAdmin} contract. If set up this way,\n * you should think of the `ProxyAdmin` instance as the real administrative interface of your proxy.\n */\ncontract TransparentUpgradeableProxy is ERC1967Proxy {\n    /**\n     * @dev Initializes an upgradeable proxy managed by `_admin`, backed by the implementation at `_logic`, and\n     * optionally initialized with `_data` as explained in {ERC1967Proxy-constructor}.\n     */\n    constructor(\n        address _logic,\n        address admin_,\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {\n        _changeAdmin(admin_);\n    }\n\n    /**\n     * @dev Modifier used internally that will delegate the call to the implementation unless the sender is the admin.\n     */\n    modifier ifAdmin() {\n        if (msg.sender == _getAdmin()) {\n            _;\n        } else {\n            _fallback();\n        }\n    }\n\n    /**\n     * @dev Returns the current admin.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyAdmin}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103`\n     */\n    function admin() external ifAdmin returns (address admin_) {\n        admin_ = _getAdmin();\n    }\n\n    /**\n     * @dev Returns the current implementation.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-getProxyImplementation}.\n     *\n     * TIP: To get this value clients can read directly from the storage slot shown below (specified by EIP1967) using the\n     * https://eth.wiki/json-rpc/API#eth_getstorageat[`eth_getStorageAt`] RPC call.\n     * `0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc`\n     */\n    function implementation() external ifAdmin returns (address implementation_) {\n        implementation_ = _implementation();\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-changeProxyAdmin}.\n     */\n    function changeAdmin(address newAdmin) external virtual ifAdmin {\n        _changeAdmin(newAdmin);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgrade}.\n     */\n    function upgradeTo(address newImplementation) external ifAdmin {\n        _upgradeToAndCall(newImplementation, bytes(\"\"), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy, and then call a function from the new implementation as specified\n     * by `data`, which should be an encoded function call. This is useful to initialize new storage variables in the\n     * proxied contract.\n     *\n     * NOTE: Only the admin can call this function. See {ProxyAdmin-upgradeAndCall}.\n     */\n    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {\n        _upgradeToAndCall(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _admin() internal view virtual returns (address) {\n        return _getAdmin();\n    }\n\n    /**\n     * @dev Makes sure the admin cannot access the fallback function. See {Proxy-_beforeFallback}.\n     */\n    function _beforeFallback() internal virtual override {\n        require(msg.sender != _getAdmin(), \"TransparentUpgradeableProxy: admin cannot fallback to proxy target\");\n        super._beforeFallback();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!Address.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/extensions/collections/HasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { HasProxyAdmin } from \"./HasProxyAdmin.sol\";\nimport \"../../interfaces/collections/IHasContracts.sol\";\nimport { IdentityGuard } from \"../../utils/IdentityGuard.sol\";\nimport { ErrUnexpectedInternalCall } from \"../../utils/CommonErrors.sol\";\n\n/**\n * @title HasContracts\n * @dev A contract that provides functionality to manage multiple contracts with different roles.\n */\nabstract contract HasContracts is HasProxyAdmin, IHasContracts, IdentityGuard {\n  /// @dev value is equal to keccak256(\"@ronin.dpos.collections.HasContracts.slot\") - 1\n  bytes32 private constant _STORAGE_SLOT = 0xdea3103d22025c269050bea94c0c84688877f12fa22b7e6d2d5d78a9a49aa1cb;\n\n  /**\n   * @dev Modifier to restrict access to functions only to contracts with a specific role.\n   * @param contractType The contract type that allowed to call\n   */\n  modifier onlyContract(ContractType contractType) virtual {\n    _requireContract(contractType);\n    _;\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function setContract(ContractType contractType, address addr) external virtual onlyAdmin {\n    _requireHasCode(addr);\n    _setContract(contractType, addr);\n  }\n\n  /**\n   * @inheritdoc IHasContracts\n   */\n  function getContract(ContractType contractType) public view returns (address contract_) {\n    contract_ = _getContractMap()[uint8(contractType)];\n    if (contract_ == address(0)) revert ErrContractTypeNotFound(contractType);\n  }\n\n  /**\n   * @dev Internal function to set the address of a contract with a specific role.\n   * @param contractType The contract type of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function _setContract(ContractType contractType, address addr) internal virtual {\n    _getContractMap()[uint8(contractType)] = addr;\n    emit ContractUpdated(contractType, addr);\n  }\n\n  /**\n   * @dev Internal function to access the mapping of contract addresses with roles.\n   * @return contracts_ The mapping of contract addresses with roles.\n   */\n  function _getContractMap() private pure returns (mapping(uint8 => address) storage contracts_) {\n    assembly {\n      contracts_.slot := _STORAGE_SLOT\n    }\n  }\n\n  /**\n   * @dev Internal function to check if the calling contract has a specific role.\n   * @param contractType The contract type that the calling contract must have.\n   * @dev Throws an error if the calling contract does not have the specified role.\n   */\n  function _requireContract(ContractType contractType) private view {\n    if (msg.sender != getContract(contractType)) {\n      revert ErrUnexpectedInternalCall(msg.sig, contractType, msg.sender);\n    }\n  }\n}\n"
    },
    "contracts/extensions/collections/HasProxyAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/StorageSlot.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract HasProxyAdmin {\n  // bytes32(uint256(keccak256(\"eip1967.proxy.admin\")) - 1));\n  bytes32 private constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n  modifier onlyAdmin() {\n    _requireAdmin();\n    _;\n  }\n\n  /**\n   * @dev Returns proxy admin.\n   */\n  function _getAdmin() internal view virtual returns (address) {\n    return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n  }\n\n  function _requireAdmin() internal view {\n    if (msg.sender != _getAdmin()) revert ErrUnauthorized(msg.sig, RoleAccess.ADMIN);\n  }\n}\n"
    },
    "contracts/extensions/consumers/GlobalConfigConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract GlobalConfigConsumer {\n  /// @dev The addition amount of gas sending along in external calls. Total gas stipend is added with default 2300 gas.\n  uint256 public constant DEFAULT_ADDITION_GAS = 1200;\n  /// @dev The length of a period in second.\n  uint256 public constant PERIOD_DURATION = 1 days;\n}\n"
    },
    "contracts/extensions/consumers/PercentageConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nabstract contract PercentageConsumer {\n  uint256 internal constant _MAX_PERCENTAGE = 100_00;\n}\n"
    },
    "contracts/extensions/RONTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nabstract contract RONTransferHelper {\n  /// @dev Error of sender has insufficient balance.\n  error ErrInsufficientBalance(bytes4 msgSig, uint256 currentBalance, uint256 sendAmount);\n  /// @dev Error of recipient not accepting RON when transfer RON.\n  error ErrRecipientRevert(bytes4 msgSig);\n\n  /**\n   * @dev See `_sendRON`.\n   * Reverts if the recipient does not receive RON.\n   */\n  function _transferRON(address payable recipient, uint256 amount) internal {\n    if (!_sendRON(recipient, amount)) revert ErrRecipientRevert(msg.sig);\n  }\n\n  /**\n   * @dev Send `amount` RON to the address `recipient`.\n   * Returns whether the recipient receives RON or not.\n   * Reverts once the contract balance is insufficient.\n   *\n   * Note: consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _sendRON(address payable recipient, uint256 amount) internal returns (bool success) {\n    if (address(this).balance < amount) revert ErrInsufficientBalance(msg.sig, address(this).balance, amount);\n    return _unsafeSendRON(recipient, amount);\n  }\n\n  /**\n   * @dev Unsafe send `amount` RON to the address `recipient`. If the sender's balance is insufficient,\n   * the call does not revert.\n   *\n   * Note:\n   * - Does not assert whether the balance of sender is sufficient.\n   * - Does not assert whether the recipient accepts RON.\n   * - Consider using `ReentrancyGuard` before calling this function.\n   *\n   */\n  function _unsafeSendRON(address payable recipient, uint256 amount) internal returns (bool success) {\n    (success, ) = recipient.call{ value: amount }(\"\");\n  }\n\n  /**\n   * @dev Same purpose with {_unsafeSendRONLimitGas(address,uin256)} but containing gas limit stipend forwarded in the call.\n   */\n  function _unsafeSendRONLimitGas(\n    address payable recipient,\n    uint256 amount,\n    uint256 gas\n  ) internal returns (bool success) {\n    // When msg.value = 0, the forwarding gas will not be auto-added 2300.\n    // We add an extra 2300 to make sure all calls will have the same amount of gas.\n    if (amount == 0) {\n      gas += 2300;\n    }\n\n    (success, ) = recipient.call{ value: amount, gas: gas }(\"\");\n  }\n}\n"
    },
    "contracts/extensions/TransparentUpgradeableProxyV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol\";\n\ncontract TransparentUpgradeableProxyV2 is TransparentUpgradeableProxy {\n  constructor(\n    address _logic,\n    address admin_,\n    bytes memory _data\n  ) payable TransparentUpgradeableProxy(_logic, admin_, _data) {}\n\n  /**\n   * @dev Calls a function from the current implementation as specified by `_data`, which should be an encoded function call.\n   *\n   * Requirements:\n   * - Only the admin can call this function.\n   *\n   * Note: The proxy admin is not allowed to interact with the proxy logic through the fallback function to avoid\n   * triggering some unexpected logic. This is to allow the administrator to explicitly call the proxy, please consider\n   * reviewing the encoded data `_data` and the method which is called before using this.\n   *\n   */\n  function functionDelegateCall(bytes memory _data) public payable ifAdmin {\n    address _addr = _implementation();\n    assembly {\n      let _result := delegatecall(gas(), _addr, add(_data, 32), mload(_data), 0, 0)\n      returndatacopy(0, 0, returndatasize())\n      switch _result\n      case 0 {\n        revert(0, returndatasize())\n      }\n      default {\n        return(0, returndatasize())\n      }\n    }\n  }\n}\n"
    },
    "contracts/interfaces/collections/IHasContracts.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\ninterface IHasContracts {\n  /// @dev Error of invalid role.\n  error ErrContractTypeNotFound(ContractType contractType);\n\n  /// @dev Emitted when a contract is updated.\n  event ContractUpdated(ContractType indexed contractType, address indexed addr);\n\n  /**\n   * @dev Returns the address of a contract with a specific role.\n   * Throws an error if no contract is set for the specified role.\n   *\n   * @param contractType The role of the contract to retrieve.\n   * @return contract_ The address of the contract with the specified role.\n   */\n  function getContract(ContractType contractType) external view returns (address contract_);\n\n  /**\n   * @dev Sets the address of a contract with a specific role.\n   * Emits the event {ContractUpdated}.\n   * @param contractType The role of the contract to set.\n   * @param addr The address of the contract to set.\n   */\n  function setContract(ContractType contractType, address addr) external;\n}\n"
    },
    "contracts/interfaces/consumers/PeriodWrapperConsumer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface PeriodWrapperConsumer {\n  struct PeriodWrapper {\n    // Inner value.\n    uint256 inner;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n}\n"
    },
    "contracts/interfaces/IFastFinalityTracking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IFastFinalityTracking {\n  /**\n   * @dev Submit list of `voters` who vote for fast finality in the current block.\n   *\n   * Requirements:\n   * - Only called once per block\n   * - Only coinbase can call this method\n   */\n  function recordFinality(address[] calldata voters) external;\n\n  /**\n   * @dev Returns vote count of `addrs` in the `period`.\n   */\n  function getManyFinalityVoteCounts(\n    uint256 period,\n    address[] calldata addrs\n  ) external view returns (uint256[] memory voteCounts);\n}\n"
    },
    "contracts/interfaces/IMaintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../udvts/Types.sol\";\n\ninterface IMaintenance {\n  /**\n   * @dev Error thrown when attempting to schedule an already scheduled event.\n   */\n  error ErrAlreadyScheduled();\n\n  /**\n   * @dev Error thrown when referring to a non-existent schedule.\n   */\n  error ErrUnexistedSchedule();\n\n  /**\n   * @dev Error thrown when the end block of a schedule is out of range.\n   */\n  error ErrEndBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when the start block of a schedule is out of range.\n   */\n  error ErrStartBlockOutOfRange();\n\n  /**\n   * @dev Error thrown when attempting to initiate maintenance while already in maintenance mode.\n   */\n  error ErrAlreadyOnMaintenance();\n\n  /**\n   * @dev Error thrown when attempting an action before the cooldown period has ended.\n   */\n  error ErrCooldownTimeNotYetEnded();\n\n  /**\n   * @dev Error thrown when the total number of schedules exceeds the limit.\n   */\n  error ErrTotalOfSchedulesExceeded();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration is specified.\n   */\n  error ErrInvalidMaintenanceDuration();\n\n  /**\n   * @dev Error thrown when an invalid maintenance duration configuration is provided.\n   */\n  error ErrInvalidMaintenanceDurationConfig();\n\n  /**\n   * @dev Error thrown when an invalid offset is specified to start the schedule configurations.\n   */\n  error ErrInvalidOffsetToStartScheduleConfigs();\n\n  struct Schedule {\n    uint256 from;\n    uint256 to;\n    uint256 lastUpdatedBlock;\n    uint256 requestTimestamp;\n  }\n\n  /// @dev Emitted when a maintenance is scheduled.\n  event MaintenanceScheduled(address indexed cid, Schedule);\n  /// @dev Emitted when a schedule of maintenance is cancelled.\n  event MaintenanceScheduleCancelled(address indexed cid);\n  /// @dev Emitted when the maintenance config is updated.\n  event MaintenanceConfigUpdated(\n    uint256 minMaintenanceDurationInBlock,\n    uint256 maxMaintenanceDurationInBlock,\n    uint256 minOffsetToStartSchedule,\n    uint256 maxOffsetToStartSchedule,\n    uint256 maxSchedules,\n    uint256 cooldownSecsToMaintain\n  );\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` maintained at the block number `_block`.\n   */\n  function checkMaintained(TConsensus consensusAddr, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator whose id `validatorId` maintained at the block number `_block`.\n   */\n  function checkMaintainedById(address validatorId, uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks.\n   */\n  function checkMaintainedInBlockRange(\n    TConsensus consensusAddr,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool);\n\n  /**\n   * @dev Returns the bool array indicating the validators maintained at block number `k` or not.\n   */\n  function checkManyMaintained(\n    TConsensus[] calldata consensusAddrList,\n    uint256 atBlock\n  ) external view returns (bool[] memory);\n\n  function checkManyMaintainedById(\n    address[] calldata candidateIdList,\n    uint256 atBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns a bool array indicating the validators maintained in the inclusive range [`_fromBlock`, `_toBlock`] of blocks or not.\n   */\n  function checkManyMaintainedInBlockRange(\n    TConsensus[] calldata _consensusAddrList,\n    uint256 _fromBlock,\n    uint256 _toBlock\n  ) external view returns (bool[] memory);\n\n  function checkManyMaintainedInBlockRangeById(\n    address[] calldata idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` has finished cooldown.\n   */\n  function checkCooldownEnded(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator `consensusAddr` has schedule.\n   */\n  function checkScheduled(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns the detailed schedule of the validator `consensusAddr`.\n   */\n  function getSchedule(TConsensus consensusAddr) external view returns (Schedule memory);\n\n  /**\n   * @dev Returns the total of current schedules.\n   */\n  function totalSchedule() external view returns (uint256 count);\n\n  /**\n   * @dev Returns the cooldown to maintain in seconds.\n   */\n  function cooldownSecsToMaintain() external view returns (uint256);\n\n  /**\n   * @dev Sets the duration restriction, start time restriction, and max allowed for maintenance.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   * - The max duration is larger than the min duration.\n   * - The max offset is larger than the min offset.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedules_,\n    uint256 cooldownSecsToMaintain_\n  ) external;\n\n  /**\n   * @dev Returns the min duration for maintenance in block.\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the max duration for maintenance in block.\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256);\n\n  /**\n   * @dev The offset to the min block number that the schedule can start\n   */\n  function minOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev The offset to the max block number that the schedule can start\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256);\n\n  /**\n   * @dev Returns the max number of scheduled maintenances.\n   */\n  function maxSchedule() external view returns (uint256);\n\n  /**\n   * @dev Schedules for maintenance from `startedAtBlock` to `endedAtBlock`.\n   *\n   * Requirements:\n   * - The candidate `consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `consensusAddr`.\n   * - The candidate `consensusAddr` has no schedule yet or the previous is done.\n   * - The total number of schedules is not larger than `maxSchedules()`.\n   * - The start block must be at least `minOffsetToStartSchedule()` and at most `maxOffsetToStartSchedule()` blocks from the current block.\n   * - The end block is larger than the start block.\n   * - The scheduled duration is larger than the `minMaintenanceDurationInBlock()` and less than the `maxMaintenanceDurationInBlock()`.\n   * - The start block is at the start of an epoch.\n   * - The end block is at the end of an epoch.\n   *\n   * Emits the event `MaintenanceScheduled`.\n   *\n   */\n  function schedule(TConsensus consensusAddr, uint256 startedAtBlock, uint256 endedAtBlock) external;\n\n  /**\n   * @dev Cancel the schedule of maintenance for the `consensusAddr`.\n   *\n   * Requirements:\n   * - The candidate `consensusAddr` is the block producer.\n   * - The method caller is candidate admin of the candidate `consensusAddr`.\n   * - A schedule for the `consensusAddr` must be existent and not executed yet.\n   *\n   * Emits the event `MaintenanceScheduleCancelled`.\n   */\n  function cancelSchedule(TConsensus consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/IProfile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId, TConsensus } from \"../udvts/Types.sol\";\nimport \"../utils/RoleAccess.sol\";\n\ninterface IProfile {\n  struct CandidateProfile {\n    /**\n     * @dev Primary key of the profile, use for backward querying.\n     *\n     * {Staking} Contract: index of pool\n     * {RoninValidatorSet} Contract: index of almost all data related to a validator\n     *\n     */\n    address id;\n    /// @dev Consensus address.\n    TConsensus consensus;\n    /// @dev Pool admin address.\n    address admin;\n    /// @dev Treasury address.\n    address payable treasury;\n    /// @dev Address to voting proposal.\n    address __reservedGovernor;\n    /// @dev Public key for fast finality.\n    bytes pubkey;\n    /// @dev Last public key change timestamp.\n    uint256 pubkeyLastChange;\n    /// @dev Old public key for fast finality.\n    bytes oldPubkey;\n  }\n\n  /// @dev Event emitted when a profile with `id` is added.\n  event ProfileAdded(address indexed id);\n\n  /// @dev Event emitted when the profile is migrated (mostly when REP-4 update).\n  event ProfileMigrated(address indexed id, address indexed admin, address indexed treasury);\n  /// @dev Event emitted when a address in a profile is changed.\n  event ProfileAddressChanged(address indexed id, RoleAccess indexed addressType, address indexed addr);\n  /// @dev Event emitted when the pubkey of the `id` is changed.\n  event PubkeyChanged(address indexed id, bytes pubkey);\n  /// @dev Event emitted when the pubkey is verified successfully.\n  event PubkeyVerified(bytes pubkey, bytes proofOfPossession);\n\n  /// @dev Error of already existed profile.\n  error ErrExistentProfile();\n  /// @dev Error of non existed profile.\n  error ErrNonExistentProfile();\n  /// @dev Error when create a new profile whose id and consensus are not identical.\n  error ErrIdAndConsensusDiffer();\n  /// @dev Error when failed to change public key because cooldown is not ended.\n  error ErrPubkeyChangeCooldownNotEnded();\n  /**\n   * @dev Error when there is a duplicated info of `value`, which is uin256-padding value of any address or hash of public key,\n   * and with value type of `infoType`.\n   */\n  error ErrDuplicatedInfo(RoleAccess infoType, uint256 value);\n  error ErrDuplicatedPubkey(bytes pubkey);\n  error ErrZeroAddress(RoleAccess infoType);\n  error ErrZeroPubkey();\n  error ErrInvalidProofOfPossession(bytes pubkey, bytes proofOfPossession);\n\n  /// @dev Getter to query full `profile` from `id` address.\n  function getId2Profile(address id) external view returns (CandidateProfile memory profile);\n\n  /// @dev Getter to batch query from `id` to `consensus`, return address(0) if the profile not exist.\n  function getManyId2Consensus(address[] calldata idList) external view returns (TConsensus[] memory consensusList);\n\n  /// @dev Getter to backward query from `consensus` address to `id` address.\n  function getConsensus2Id(TConsensus consensus) external view returns (address id);\n\n  /// @dev Getter to backward batch query from `consensus` address to `id` address.\n  function getManyConsensus2Id(TConsensus[] memory consensus) external view returns (address[] memory);\n\n  /**\n   * @notice Add a new profile.\n   *\n   * @dev Requirements:\n   * - The profile must not be existent before.\n   * - Only contract admin can call this method.\n   */\n  function addNewProfile(CandidateProfile memory profile) external;\n\n  /**\n   * @dev Cross-contract function to add/update new profile of a validator candidate when they\n   * applying for candidate role.\n   *\n   * Requirements:\n   * - Only `stakingContract` can call this method.\n   */\n  function execApplyValidatorCandidate(\n    address admin,\n    address id,\n    address treasury,\n    bytes calldata pubkey,\n    bytes calldata proofOfPossession\n  ) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeAdminAddress(address id, address newAdminAddr) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeConsensusAddr(address id, TConsensus newConsensusAddr) external;\n\n  /**\n   * @dev Updated the treasury address of candidate id `id` immediately without waiting time.\n   *\n   * Emit an {ProfileAddressChanged}.\n   */\n  function requestChangeTreasuryAddr(address id, address payable newTreasury) external;\n\n  /**\n   * @notice The candidate admin changes the public key.\n   *\n   * @dev Requirements:\n   * - The profile must be existed.\n   * - Only user with candidate admin role can call this method.\n   * - New public key must not be duplicated.\n   * - The proof of public key possession must be verified successfully.\n   * - The public key change cooldown must be ended.\n   */\n\n  function changePubkey(address id, bytes memory pubkey, bytes memory proofOfPossession) external;\n\n  /**\n   * @dev Cross-contract function to for slash indicator to check the list of public\n   * keys in finality slash proof\n   *\n   * Returns whether all public keys are registered.\n   */\n\n  function arePublicKeysRegistered(bytes[][2] calldata listOfPublicKey) external view returns (bool);\n\n  /**\n   * @dev Change the cooldown between 2 public key change\n   *\n   * Requirement:\n   *  - Only admin can call this method\n   */\n  function setPubkeyChangeCooldown(uint256 cooldown) external;\n}\n"
    },
    "contracts/interfaces/IQuorum.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IQuorum {\n  /// @dev Emitted when the threshold is updated\n  event ThresholdUpdated(\n    uint256 indexed nonce,\n    uint256 indexed numerator,\n    uint256 indexed denominator,\n    uint256 previousNumerator,\n    uint256 previousDenominator\n  );\n\n  /**\n   * @dev Returns the threshold.\n   */\n  function getThreshold() external view returns (uint256 _num, uint256 _denom);\n\n  /**\n   * @dev Checks whether the `_voteWeight` passes the threshold.\n   */\n  function checkThreshold(uint256 _voteWeight) external view returns (bool);\n\n  /**\n   * @dev Returns the minimum vote weight to pass the threshold.\n   */\n  function minimumVoteWeight() external view returns (uint256);\n\n  /**\n   * @dev Sets the threshold.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external returns (uint256 _previousNum, uint256 _previousDenom);\n}\n"
    },
    "contracts/interfaces/IRoninGovernanceAdmin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../utils/CommonErrors.sol\";\n\ninterface IRoninGovernanceAdmin {\n  /// @dev Emitted when an emergency exit poll is created.\n  event EmergencyExitPollCreated(\n    bytes32 voteHash,\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  );\n  /// @dev Emitted when an emergency exit poll is approved.\n  event EmergencyExitPollApproved(bytes32 voteHash);\n  /// @dev Emitted when an emergency exit poll is expired.\n  event EmergencyExitPollExpired(bytes32 voteHash);\n  /// @dev Emitted when an emergency exit poll is voted.\n  event EmergencyExitPollVoted(bytes32 indexed voteHash, address indexed voter);\n\n  /**\n   * @dev Create a vote to agree that an emergency exit is valid and should return the locked funds back.a\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   */\n  function createEmergencyExitPoll(\n    address validatorId,\n    address recipientAfterUnlockedFund,\n    uint256 requestedAt,\n    uint256 expiredAt\n  ) external;\n}\n"
    },
    "contracts/interfaces/IRoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IQuorum.sol\";\nimport \"../udvts/Types.sol\";\n\ninterface IRoninTrustedOrganization is IQuorum {\n  /**\n   * @dev Error indicating that a query for a duplicate entry was made.\n   */\n  error ErrQueryForDupplicated();\n\n  /**\n   * @dev Error indicating that a query was made for a non-existent consensus address.\n   */\n  error ErrQueryForNonExistentConsensusAddress();\n\n  /**\n   * @dev Error indicating that a governor address has already been added.\n   * @param addr The address of the governor that is already added.\n   */\n  error ErrGovernorAddressIsAlreadyAdded(address addr);\n\n  /**\n   * @dev Error indicating that a consensus address is not added.\n   * @param addr The address of the consensus contract that is not added.\n   */\n  error ErrConsensusAddressIsNotAdded(TConsensus addr);\n\n  /**\n   * @dev Error indicating that a consensus address is already added.\n   * @param addr The address of the consensus contract that is already added.\n   */\n  error ErrConsensusAddressIsAlreadyAdded(TConsensus addr);\n\n  struct TrustedOrganization {\n    // Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n    TConsensus consensusAddr;\n    // Address to voting proposal\n    address governor;\n    // Address to voting bridge operators\n    address __deprecatedBridgeVoter;\n    // Its Weight\n    uint256 weight;\n    // The block that the organization was added\n    uint256 addedBlock;\n  }\n\n  /// @dev Emitted when the trusted organization is added.\n  event TrustedOrganizationsAdded(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is updated.\n  event TrustedOrganizationsUpdated(TrustedOrganization[] orgs);\n  /// @dev Emitted when the trusted organization is removed.\n  event TrustedOrganizationsRemoved(TConsensus[] orgs);\n  /// @dev Emitted when the consensus address of a trusted organization is changed.\n  event ConsensusAddressOfTrustedOrgChanged(TrustedOrganization orgAfterChanged, TConsensus oldConsensus);\n\n  /**\n   * @dev Adds a list of addresses into the trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   * - The field `addedBlock` should be blank.\n   *\n   * Emits the event `TrustedOrganizationAdded` once an organization is added.\n   *\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata) external;\n\n  /**\n   * @dev Updates weights for a list of existent trusted organization.\n   *\n   * Requirements:\n   * - The weights should larger than 0.\n   * - The method caller is admin.\n   *\n   * Emits the `TrustedOrganizationUpdated` event.\n   *\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata list) external;\n\n  /**\n   * @dev Removes a list of addresses from the trusted organization.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `TrustedOrganizationRemoved` once an organization is removed.\n   *\n   * @param consensusAddrs The list of consensus addresses linked to corresponding trusted organization that to be removed.\n   */\n  function removeTrustedOrganizations(TConsensus[] calldata consensusAddrs) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeConsensusAddress`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   *\n   * Emits the event `ConsensusAddressOfTrustedOrgChanged` once an organization is removed.\n   */\n  function execChangeConsensusAddressForTrustedOrg(TConsensus oldConsensusAddr, TConsensus newConsensusAddr) external;\n\n  /**\n   * @dev Returns total weights.\n   */\n  function totalWeight() external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeight(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a consensus.\n   */\n  function getConsensusWeightById(address cid) external view returns (uint256);\n\n  /**\n   * @dev Returns the weight of a governor.\n   */\n  function getGovernorWeight(address governor) external view returns (uint256);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeights(TConsensus[] calldata list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of consensus addresses.\n   */\n  function getConsensusWeightsById(address[] calldata cids) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the weights of a list of governor addresses.\n   */\n  function getGovernorWeights(address[] calldata list) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns total weights of the consensus list.\n   */\n  function sumConsensusWeight(TConsensus[] calldata list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns total weights of the governor list.\n   */\n  function sumGovernorWeight(address[] calldata list) external view returns (uint256 _res);\n\n  /**\n   * @dev Returns the trusted organization at `_index`.\n   */\n  function getTrustedOrganizationAt(uint256 index) external view returns (TrustedOrganization memory);\n\n  /**\n   * @dev Returns the number of trusted organizations.\n   */\n  function countTrustedOrganization() external view returns (uint256);\n\n  /**\n   * @dev Returns all of the trusted organizations.\n   */\n  function getAllTrustedOrganizations() external view returns (TrustedOrganization[] memory);\n\n  /**\n   * @dev Returns the trusted organization by consensus address.\n   *\n   * Reverts once the consensus address is non-existent.\n   */\n  function getTrustedOrganization(TConsensus consensusAddr) external view returns (TrustedOrganization memory);\n}\n"
    },
    "contracts/interfaces/IStakingVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IStakingVesting {\n  /**\n   * @dev Error thrown when attempting to send a bonus that has already been sent.\n   */\n  error ErrBonusAlreadySent();\n\n  /// @dev Emitted when the block bonus for block producer is transferred.\n  event BonusTransferred(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount\n  );\n  /// @dev Emitted when the transfer of block bonus for block producer is failed.\n  event BonusTransferFailed(\n    uint256 indexed blockNumber,\n    address indexed recipient,\n    uint256 blockProducerAmount,\n    uint256 bridgeOperatorAmount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the block bonus for block producer is updated\n  event BlockProducerBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the block bonus for bridge operator is updated\n  event BridgeOperatorBonusPerBlockUpdated(uint256);\n  /// @dev Emitted when the percent of fast finality reward is updated\n  event FastFinalityRewardPercentageUpdated(uint256);\n\n  /**\n   * @dev Returns the bonus amount for the block producer at `blockNum`.\n   */\n  function blockProducerBlockBonus(uint256 blockNum) external view returns (uint256);\n\n  /**\n   * @dev Returns the bonus amount for the bridge validator at `blockNum`.\n   */\n  function bridgeOperatorBlockBonus(uint256 blockNum) external view returns (uint256);\n\n  /**\n   * @dev Returns the percentage of fast finality reward.\n   */\n  function fastFinalityRewardPercentage() external view returns (uint256);\n\n  /**\n   * @dev Receives RON from any address.\n   */\n  function receiveRON() external payable;\n\n  /**\n   * @dev Returns the last block number that the staking vesting is sent.\n   */\n  function lastBlockSendingBonus() external view returns (uint256);\n\n  /**\n   * @dev Transfers the staking vesting for the block producer and the bridge operator whenever a new block is mined.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   * - The method must be called only once per block.\n   *\n   * Emits the event `BonusTransferred` or `BonusTransferFailed`.\n   *\n   * Notes:\n   * - The method does not revert when the contract balance is insufficient to send bonus. This assure the submit reward method\n   * will not be reverted, and the underlying nodes does not hang.\n   *\n   * @param forBlockProducer Indicates whether requesting the bonus for the block procucer, in case of being in jail or relevance.\n   * @param forBridgeOperator Indicates whether requesting the bonus for the bridge operator.\n   *\n   * @return success Whether the transfer is successfully. This returns false mostly because this contract is out of balance.\n   * @return blockProducerBonus The amount of bonus actually sent for the block producer, returns 0 when the transfer is failed.\n   * @return bridgeOperatorBonus The amount of bonus actually sent for the bridge operator, returns 0 when the transfer is failed.\n   * @return fastFinalityRewardPercentage The percent of fast finality reward, returns 0 when the transfer is failed.\n   *\n   */\n  function requestBonus(\n    bool forBlockProducer,\n    bool forBridgeOperator\n  )\n    external\n    returns (\n      bool success,\n      uint256 blockProducerBonus,\n      uint256 bridgeOperatorBonus,\n      uint256 fastFinalityRewardPercentage\n    );\n\n  /**\n   * @dev Sets the bonus amount per block for block producer.\n   *\n   * Emits the event `BlockProducerBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBlockProducerBonusPerBlock(uint256 amount) external;\n\n  /**\n   * @dev Sets the bonus amount per block for bridge operator.\n   *\n   * Emits the event `BridgeOperatorBonusPerBlockUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setBridgeOperatorBonusPerBlock(uint256 _amount) external;\n\n  /**\n   * @dev Sets the percent of fast finality reward.\n   *\n   * Emits the event `FastFinalityRewardPercentageUpdated`.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   */\n  function setFastFinalityRewardPercentage(uint256 _percent) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/IBaseSlash.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IBaseSlash {\n  enum SlashType {\n    UNKNOWN,\n    UNAVAILABILITY_TIER_1,\n    UNAVAILABILITY_TIER_2,\n    DOUBLE_SIGNING,\n    BRIDGE_VOTING,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_1,\n    BRIDGE_OPERATOR_MISSING_VOTE_TIER_2,\n    UNAVAILABILITY_TIER_3,\n    FAST_FINALITY\n  }\n\n  /// @dev Error thrown when evidence has already been submitted.\n  error ErrEvidenceAlreadySubmitted();\n\n  /// @dev Error thrown when public key in evidence is not registered.\n  error ErrUnregisteredPublicKey();\n\n  /// @dev Emitted when the validator is slashed.\n  event Slashed(address indexed validator, SlashType slashType, uint256 period);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ICreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICreditScore {\n  /**\n   * @dev Error thrown when an invalid credit score configuration is provided.\n   */\n  error ErrInvalidCreditScoreConfig();\n\n  /**\n   * @dev Error thrown when an invalid cut-off percentage configuration is provided.\n   */\n  error ErrInvalidCutOffPercentageConfig();\n\n  /**\n   * @dev Error thrown when the caller's credit score is insufficient to bail out a situation.\n   */\n  error ErrInsufficientCreditScoreToBailOut();\n\n  /**\n   * @dev Error thrown when a validator has previously bailed out.\n   */\n  error ErrValidatorHasBailedOutPreviously();\n\n  /**\n   * @dev Error thrown when the caller must be jailed in the current period.\n   */\n  error ErrCallerMustBeJailedInTheCurrentPeriod();\n\n  /// @dev Emitted when the configs to credit score is updated. See the method `setCreditScoreConfigs` for param details.\n  event CreditScoreConfigsUpdated(\n    uint256 gainCreditScore,\n    uint256 maxCreditScore,\n    uint256 bailOutCostMultiplier,\n    uint256 cutOffPercentageAfterBailout\n  );\n  /// @dev Emitted the credit score of validators is updated.\n  event CreditScoresUpdated(address[] validators, uint256[] creditScores);\n  /// @dev Emitted when a validator bailed out of jail.\n  event BailedOut(address indexed cid, uint256 period, uint256 usedCreditScore);\n\n  /**\n   * @dev Updates the credit score for the validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execUpdateCreditScores(address[] calldata validatorIds, uint256 period) external;\n\n  /**\n   * @dev Resets the credit score for the revoked validators.\n   *\n   * Requirements:\n   * - Only validator contract can call this method.\n   * - This method is only called at the end of each period.\n   *\n   * Emits the event `CreditScoresUpdated`.\n   *\n   */\n  function execResetCreditScores(address[] calldata validatorIds) external;\n\n  /**\n   * @dev A slashed validator use this method to get out of jail.\n   *\n   * Requirements:\n   * - The `_consensusAddr` must be a validator.\n   * - Only validator's admin can call this method.\n   *\n   * Emits the event `BailedOut`.\n   *\n   */\n  function bailOut(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Sets the configs to credit score.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CreditScoreConfigsUpdated`.\n   *\n   * @param _gainScore The score to gain per period.\n   * @param _maxScore The max number of credit score that a validator can hold.\n   * @param _bailOutMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @param _cutOffPercentage The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external;\n\n  /**\n   * @dev Returns the configs related to credit score.\n   *\n   * @return _gainCreditScore The score to gain per period.\n   * @return _maxCreditScore The max number of credit score that a validator can hold.\n   * @return _bailOutCostMultiplier The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n   * @return _cutOffPercentageAfterBailout The percentage of reward that the block producer will be cut off from until the end of the period after bailing out.\n   *\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    returns (\n      uint256 _gainCreditScore,\n      uint256 _maxCreditScore,\n      uint256 _bailOutCostMultiplier,\n      uint256 _cutOffPercentageAfterBailout\n    );\n\n  /**\n   * @dev Returns the current credit score of the validator.\n   */\n  function getCreditScore(TConsensus consensus) external view returns (uint256);\n\n  /**\n   * @dev Returns the current credit score of a list of validators.\n   */\n  function getManyCreditScores(\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory _resultList);\n\n  /**\n   * @dev Returns the whether the `consensus` has been bailed out at the `period`.\n   */\n  function checkBailedOutAtPeriod(TConsensus consensus, uint256 period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashDoubleSign is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash double sign is updated. See the method `getDoubleSignSlashingConfigs`\n   * for param details.\n   */\n  event DoubleSignSlashingConfigsUpdated(\n    uint256 slashDoubleSignAmount,\n    uint256 doubleSigningJailUntilBlock,\n    uint256 doubleSigningOffsetLimitBlock\n  );\n\n  /**\n   * @dev Slashes for double signing.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` if the double signing evidence of the two headers valid.\n   */\n  function slashDoubleSign(TConsensus _validatorAddr, bytes calldata _header1, bytes calldata _header2) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return _slashDoubleSignAmount The amount of RON to slash double sign.\n   * @return _doubleSigningJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    returns (\n      uint256 _slashDoubleSignAmount,\n      uint256 _doubleSigningJailUntilBlock,\n      uint256 _doubleSigningOffsetLimitBlock\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `DoubleSignSlashingConfigsUpdated`.\n   *\n   * @param _slashAmount The amount of RON to slash double sign.\n   * @param _jailUntilBlock The block number that the punished validator will be jailed until, due to double signing.\n   * @param _doubleSigningOffsetLimitBlock The number of block that the current block is at most far from the double\n   * signing block.\n   *\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _doubleSigningOffsetLimitBlock\n  ) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashFastFinality is IBaseSlash {\n  /**\n   * @dev Emitted when the configs to slash fast finality is updated. See the method `getFastFinalitySlashingConfigs`\n   * for param details.\n   */\n  event FastFinalitySlashingConfigsUpdated(uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Slashes for fast finality.\n   *\n   * Requirements:\n   * - Only whitelisted addresses are allowed to call.\n   *\n   * Emits the event `Slashed` if the fast finality evidence of the two headers valid.\n   */\n  function slashFastFinality(\n    TConsensus consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external;\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return slashFastFinalityAmount The amount of RON to slash fast finality.\n   * @return fastFinalityJailUntilBlock The block number that the punished validator will be jailed until, due to\n   * malicious fast finality.\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    returns (uint256 slashFastFinalityAmount, uint256 fastFinalityJailUntilBlock);\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `FastFinalitySlashingConfigsUpdated`.\n   *\n   * @param slashAmount The amount of RON to slash fast finality.\n   * @param jailUntilBlock The block number that the punished validator will be jailed until, due to fast finality.\n   *\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external;\n}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashDoubleSign.sol\";\nimport \"./ISlashUnavailability.sol\";\nimport \"./ICreditScore.sol\";\n\ninterface ISlashIndicator is\n  ISlashDoubleSign,\n  ISlashUnavailability,\n  ICreditScore\n{}\n"
    },
    "contracts/interfaces/slash-indicator/ISlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseSlash.sol\";\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ISlashUnavailability is IBaseSlash {\n  /**\n   * @dev Error thrown when attempting to slash a validator twice or slash more than one validator in one block.\n   */\n  error ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n\n  /**\n   * @dev Emitted when the configs to slash bridge operator is updated. See the method `getUnavailabilitySlashingConfigs`\n   * for param details.\n   */\n  event UnavailabilitySlashingConfigsUpdated(\n    uint256 unavailabilityTier1Threshold,\n    uint256 unavailabilityTier2Threshold,\n    uint256 slashAmountForUnavailabilityTier2Threshold,\n    uint256 jailDurationForUnavailabilityTier2Threshold\n  );\n\n  /**\n   * @dev Returns the last block that a block producer is slashed for unavailability.\n   */\n  function lastUnavailabilitySlashedBlock() external view returns (uint256);\n\n  /**\n   * @dev Slashes for unavailability by increasing the counter of block producer `consensusAddr`.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `Slashed` when the threshold is reached.\n   *\n   */\n  function slashUnavailability(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Returns the current unavailability indicator of a block producer.\n   */\n  function currentUnavailabilityIndicator(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the unavailability indicator in the period `period` of a block producer.\n   */\n  function getUnavailabilityIndicator(TConsensus consensusAddr, uint256 period) external view returns (uint256);\n\n  /**\n   * @dev Returns the configs related to block producer slashing.\n   *\n   * @return unavailabilityTier1Threshold The mining reward will be deprecated, if (s)he missed more than this\n   * threshold. This threshold is applied for tier-1 and tier-3 slash.\n   * @return unavailabilityTier2Threshold  The mining reward will be deprecated, (s)he will be put in jailed, and will\n   * be deducted self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   * @return slashAmountForUnavailabilityTier2Threshold The amount of RON to deduct from self-staking of a block\n   * producer when (s)he is slashed with tier-2 or tier-3.\n   * @return jailDurationForUnavailabilityTier2Threshold The number of blocks to jail a block producer when (s)he is\n   * slashed with tier-2 or tier-3.\n   *\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    returns (\n      uint256 unavailabilityTier1Threshold,\n      uint256 unavailabilityTier2Threshold,\n      uint256 slashAmountForUnavailabilityTier2Threshold,\n      uint256 jailDurationForUnavailabilityTier2Threshold\n    );\n\n  /**\n   * @dev Sets the configs to slash block producers.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `BridgeOperatorSlashingConfigsUpdated`.\n   *\n   * @param tier1Threshold The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * @param tier2Threshold The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold.\n   * @param slashAmountForTier2Threshold The amount of RON to deduct from self-staking of a block producer when (s)he\n   * is slashed tier-2.\n   * @param jailDurationForTier2Threshold The number of blocks to jail a block producer when (s)he is slashed tier-2.\n   *\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 tier1Threshold,\n    uint256 tier2Threshold,\n    uint256 slashAmountForTier2Threshold,\n    uint256 jailDurationForTier2Threshold\n  ) external;\n}\n"
    },
    "contracts/interfaces/staking/IBaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\ninterface IBaseStaking {\n  struct PoolDetail {\n    /**\n     * @dev Address of the pool.\n     * @custom non-volatile-storage Permanently set to the first consensus address of the candidate.\n     */\n    address pid;\n\n    /**\n     * @dev The address of the pool admin.\n     * @custom shadowed-storage This storage slot is always kept in sync with the admin in `Profile-CandidateProfile`.\n     */\n    address __shadowedPoolAdmin;\n\n    /// @dev Self-staking amount\n    uint256 stakingAmount;\n\n    /// @dev Total number of RON staking for the pool\n    uint256 stakingTotal;\n\n    /// @dev Mapping from delegator => delegating amount\n    mapping(address => uint256) delegatingAmount;\n\n    /// @dev Mapping from delegator => the last timestamp that delegator staked\n    mapping(address => uint256) lastDelegatingTimestamp;\n  }\n\n  /// @dev Emitted when the minium number of seconds to undelegate is updated.\n  event CooldownSecsToUndelegateUpdated(uint256 minSecs);\n  /// @dev Emitted when the number of seconds that a candidate must wait to be revoked.\n  event WaitingSecsToRevokeUpdated(uint256 secs);\n\n  /// @dev Error of cannot transfer RON.\n  error ErrCannotTransferRON();\n  /// @dev Error of receiving zero message value.\n  error ErrZeroValue();\n  /// @dev Error of pool admin is not allowed to call.\n  error ErrPoolAdminForbidden();\n  /// @dev Error of no one is allowed to call but the pool's admin.\n  error ErrOnlyPoolAdminAllowed();\n  /// @dev Error of admin of any active pool cannot delegate.\n  error ErrAdminOfAnyActivePoolForbidden(address admin);\n  /// @dev Error of querying inactive pool.\n  error ErrInactivePool(TConsensus consensusAddr, address poolAddr);\n  /// @dev Error of length of input arrays are not of the same.\n  error ErrInvalidArrays();\n\n  /**\n   * @dev Returns whether the `admin` is currently active.\n   */\n  function isAdminOfActivePool(address admin) external view returns (bool);\n\n  /**\n   * @dev Returns the consensus address corresponding to the pool admin.\n   */\n  function getPoolAddressOf(address admin) external view returns (address);\n\n  /**\n   * @dev Returns the staking pool details.\n   */\n  function getPoolDetail(\n    TConsensus consensusAddr\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal);\n\n  function getPoolDetailById(\n    address poolId\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakings(TConsensus[] calldata consensusAddrs) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the self-staking amounts of the pools.\n   */\n  function getManySelfStakingsById(address[] calldata poolIds) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of seconds that a candidate must wait for the renounce request gets affected.\n   */\n  function waitingSecsToRevoke() external view returns (uint256);\n\n  /**\n   * @dev Sets the cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function setCooldownSecsToUndelegate(uint256 cooldownSecs) external;\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function setWaitingSecsToRevoke(uint256 secs) external;\n}\n"
    },
    "contracts/interfaces/staking/ICandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface ICandidateStaking is IRewardPool {\n  /// @dev Emitted when the minimum staking amount for being a validator is updated.\n  event MinValidatorStakingAmountUpdated(uint256 threshold);\n  /// @dev Emitted when the commission rate range is updated.\n  event CommissionRateRangeUpdated(uint256 minRate, uint256 maxRate);\n\n  /// @dev Emitted when the pool admin staked for themself.\n  event Staked(address indexed poolId, uint256 amount);\n  /// @dev Emitted when the pool admin unstaked the amount of RON from themself.\n  event Unstaked(address indexed poolId, uint256 amount);\n\n  /// @dev Emitted when the validator pool is approved.\n  event PoolApproved(address indexed validator, address indexed admin);\n  /// @dev Emitted when the validator pool is deprecated.\n  event PoolsDeprecated(address[] validator);\n  /// @dev Emitted when the staking amount transfer failed.\n  event StakingAmountTransferFailed(\n    address indexed poolId,\n    address indexed admin,\n    uint256 amount,\n    uint256 contractBalance\n  );\n  /// @dev Emitted when the staking amount deducted failed, e.g. when the validator gets slashed.\n  event StakingAmountDeductFailed(\n    address indexed poolId,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Error of cannot transfer RON to specified target.\n  error ErrCannotInitTransferRON(address addr, string extraInfo);\n  /// @dev Error of three interaction addresses must be of the same in applying for validator candidate.\n  error ErrThreeInteractionAddrsNotEqual();\n  /// @dev Error of unstaking zero amount.\n  error ErrUnstakeZeroAmount();\n  /// @dev Error of invalid staking amount left after deducted.\n  error ErrStakingAmountLeft();\n  /// @dev Error of insufficient staking amount for unstaking.\n  error ErrInsufficientStakingAmount();\n  /// @dev Error of unstaking too early.\n  error ErrUnstakeTooEarly();\n  /// @dev Error of setting commission rate exceeds max allowed.\n  error ErrInvalidCommissionRate();\n\n  /**\n   * @dev Returns the minimum threshold for being a validator candidate.\n   */\n  function minValidatorStakingAmount() external view returns (uint256);\n\n  /**\n   * @dev Returns the commission rate range that the candidate can set.\n   */\n  function getCommissionRateRange() external view returns (uint256 minRange, uint256 maxRange);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function setMinValidatorStakingAmount(uint256) external;\n\n  /**\n   * @dev Sets the commission rate range that a candidate can set.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `CommissionRateRangeUpdated` event.\n   *\n   */\n  function setCommissionRateRange(uint256 minRate, uint256 maxRate) external;\n\n  /**\n   * @dev Proposes a candidate to become a validator.\n   *\n   * Requirements:\n   * - The method caller is able to receive RON.\n   * - The treasury is able to receive RON.\n   * - The amount is larger than or equal to the minimum validator staking amount `minValidatorStakingAmount()`.\n   *\n   * Emits the event `PoolApproved`.\n   *\n   * @param candidateAdmin the candidate admin will be stored in the validator contract, used for calling function that affects\n   * to its candidate, e.g. scheduling maintenance.\n   *\n   */\n  function applyValidatorCandidate(\n    address candidateAdmin,\n    TConsensus consensusAddr,\n    address payable treasuryAddr,\n    uint256 commissionRate,\n    bytes calldata pubkey,\n    bytes calldata proofOfPossession\n  ) external payable;\n\n  /**\n   * @dev Deprecates the pool.\n   * - Deduct self-staking amount of the pool admin to zero.\n   * - Transfer the deducted amount to the pool admin.\n   * - Deactivate the pool admin address in the mapping of active pool admins\n   *\n   * Requirements:\n   * - The method caller is validator contract.\n   *\n   * Emits the event `PoolsDeprecated` and `Unstaked` events.\n   * Emits the event `StakingAmountTransferFailed` if the contract cannot transfer RON back to the pool admin.\n   *\n   */\n  function execDeprecatePools(address[] calldata pools, uint256 period) external;\n\n  /**\n   * @dev Self-delegates to the validator candidate `consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `msg.value` is larger than 0.\n   *\n   * Emits the event `Staked`.\n   *\n   */\n  function stake(TConsensus consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from the validator candidate `consensusAddr` for `amount`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function unstake(TConsensus consensusAddr, uint256 amount) external;\n\n  /**\n   * @dev Pool admin requests update validator commission rate. The request will be forwarded to the candidate manager\n   * contract, and the value is getting updated in {ICandidateManager-execRequestUpdateCommissionRate}.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   * - The `_effectiveDaysOnwards` must be equal to or larger than the {CandidateManager-_minEffectiveDaysOnwards}.\n   * - The `_rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdated`.\n   *\n   */\n  function requestUpdateCommissionRate(\n    TConsensus consensusAddr,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  ) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestRenounce(TConsensus consensusAddr) external;\n\n  /**\n   * @dev Renounces being a validator candidate and takes back the delegating/staking amount.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is the pool admin.\n   *\n   */\n  function requestEmergencyExit(TConsensus consensusAddr) external;\n}\n"
    },
    "contracts/interfaces/staking/IDelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IRewardPool.sol\";\n\ninterface IDelegatorStaking is IRewardPool {\n  /// @dev Emitted when the delegator staked for a validator candidate.\n  event Delegated(address indexed delegator, address indexed poolId, uint256 amount);\n  /// @dev Emitted when the delegator unstaked from a validator candidate.\n  event Undelegated(address indexed delegator, address indexed poolId, uint256 amount);\n\n  /// @dev Error of undelegating zero amount.\n  error ErrUndelegateZeroAmount();\n  /// @dev Error of undelegating insufficient amount.\n  error ErrInsufficientDelegatingAmount();\n  /// @dev Error of undelegating too early.\n  error ErrUndelegateTooEarly();\n\n  /**\n   * @dev Stakes for a validator candidate `_consensusAddr`.\n   *\n   * Requirements:\n   * - The consensus address is a validator candidate.\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   */\n  function delegate(TConsensus consensusAddr) external payable;\n\n  /**\n   * @dev Unstakes from a validator candidate `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the `Undelegated` event.\n   *\n   */\n  function undelegate(TConsensus consensusAddr, uint256 amount) external;\n\n  /**\n   * @dev Bulk unstakes from a list of candidates.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   *\n   * Emits the events `Undelegated`.\n   *\n   */\n  function bulkUndelegate(TConsensus[] calldata consensusAddrs, uint256[] calldata amounts) external;\n\n  /**\n   * @dev Unstakes an amount of RON from the `_consensusAddrSrc` and stake for `_consensusAddrDst`.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `Undelegated` event and the `Delegated` event.\n   *\n   */\n  function redelegate(TConsensus consensusAddrSrc, TConsensus consensusAddrDst, uint256 amount) external;\n\n  /**\n   * @dev Returns the claimable reward of the user `_user`.\n   */\n  function getRewards(\n    address user,\n    TConsensus[] calldata consensusAddrList\n  ) external view returns (uint256[] memory _rewards);\n\n  /**\n   * @dev Claims the reward of method caller.\n   *\n   * Emits the `RewardClaimed` event.\n   *\n   */\n  function claimRewards(TConsensus[] calldata consensusAddrList) external returns (uint256 amount);\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   *\n   * Requirements:\n   * - The method caller is not the pool admin.\n   * - The consensus address `_consensusAddrDst` is a validator candidate.\n   *\n   * Emits the `RewardClaimed` event and the `Delegated` event.\n   *\n   */\n  function delegateRewards(\n    TConsensus[] calldata consensusAddrList,\n    TConsensus consensusAddrDst\n  ) external returns (uint256 amount);\n}\n"
    },
    "contracts/interfaces/staking/IRewardPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/consumers/PeriodWrapperConsumer.sol\";\n\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\ninterface IRewardPool is PeriodWrapperConsumer {\n  struct UserRewardFields {\n    // Recorded reward amount.\n    uint256 debited;\n    // The last accumulated of the amount rewards per share (one unit staking) that the info updated.\n    uint256 aRps;\n    // Lowest staking amount in the period.\n    uint256 lowestAmount;\n    // Last period number that the info updated.\n    uint256 lastPeriod;\n  }\n\n  struct PoolFields {\n    // Accumulated of the amount rewards per share (one unit staking).\n    uint256 aRps;\n    // The staking total to share reward of the current period.\n    PeriodWrapper shares;\n  }\n\n  /// @dev Emitted when the fields to calculate pending reward for the user is updated.\n  event UserRewardUpdated(address indexed poolAddr, address indexed user, uint256 debited);\n  /// @dev Emitted when the user claimed their reward\n  event RewardClaimed(address indexed poolAddr, address indexed user, uint256 amount);\n\n  /// @dev Emitted when the pool shares are updated\n  event PoolSharesUpdated(uint256 indexed period, address indexed poolAddr, uint256 shares);\n  /// @dev Emitted when the pools are updated\n  event PoolsUpdated(uint256 indexed period, address[] poolAddrs, uint256[] aRps, uint256[] shares);\n  /// @dev Emitted when the contract fails when updating the pools\n  event PoolsUpdateFailed(uint256 indexed period, address[] poolAddrs, uint256[] rewards);\n  /// @dev Emitted when the contract fails when updating the pools that already set\n  event PoolsUpdateConflicted(uint256 indexed period, address[] poolAddrs);\n\n  /// @dev Error of invalid pool share.\n  error ErrInvalidPoolShare();\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function getReward(TConsensus consensusAddr, address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amount of an user.\n   */\n  function getStakingAmount(TConsensus consensusAddr, address user) external view returns (uint256);\n\n  /**\n   * @dev Returns the staking amounts of the users.\n   */\n  function getManyStakingAmounts(\n    TConsensus[] calldata consensusAddrs,\n    address[] calldata userList\n  ) external view returns (uint256[] memory);\n\n  function getManyStakingAmountsById(\n    address[] calldata poolIds,\n    address[] calldata userList\n  ) external view returns (uint256[] memory);\n\n  /**\n   * @dev Returns the total staking amount of all users for a pool.\n   */\n  function getStakingTotal(TConsensus consensusAddr) external view returns (uint256);\n\n  /**\n   * @dev Returns the total staking amounts of all users for the pools `_poolAddrs`.\n   */\n  function getManyStakingTotals(TConsensus[] calldata consensusAddrs) external view returns (uint256[] memory);\n\n  function getManyStakingTotalsById(\n    address[] calldata poolIds\n  ) external view returns (uint256[] memory stakingAmounts_);\n}\n"
    },
    "contracts/interfaces/staking/IStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IBaseStaking.sol\";\nimport \"./IStakingCallback.sol\";\nimport \"./ICandidateStaking.sol\";\nimport \"./IDelegatorStaking.sol\";\n\ninterface IStaking is IRewardPool, IBaseStaking, ICandidateStaking, IDelegatorStaking, IStakingCallback {\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `_consensusAddrs`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolsUpdateConflicted` when there are some pools which already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function execRecordRewards(address[] calldata poolIds, uint256[] calldata rewards, uint256 period) external payable;\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Requirements:\n   * - The method caller must be validator contract.\n   *\n   * Emits the event `Unstaked`.\n   *\n   */\n  function execDeductStakingAmount(address poolId, uint256 amount) external returns (uint256 actualDeductingAmount);\n}\n"
    },
    "contracts/interfaces/staking/IStakingCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TPoolId } from \"../../udvts/Types.sol\";\n\ninterface IStakingCallback {\n  /**\n   * @dev Requirements:\n   * - Only Profile contract can call this method.\n   */\n  function execChangeAdminAddress(address poolAddr, address newAdminAddr) external;\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICandidateManager {\n  struct ValidatorCandidate {\n    /**\n     * @dev The address of the candidate admin.\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.admin.\n     */\n    address __shadowedAdmin;\n    /**\n     * @dev Address of the validator that produces block, e.g. block.coinbase. This is so-called validator address.\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.consensus.\n     */\n    TConsensus __shadowedConsensus;\n    /**\n     * @dev Address that receives mining reward of the validator\n     * @custom shadowed-storage This storage slot is always kept in sync with {Profile-CandidateProfile}.treasury.\n     */\n    address payable __shadowedTreasury;\n    /// @dev Address of the bridge operator corresponding to the candidate\n    address ____deprecatedBridgeOperatorAddr;\n    /**\n     * @dev The percentage of reward that validators can be received, the rest goes to the delegators.\n     * Values in range [0; 100_00] stands for 0-100%\n     */\n    uint256 commissionRate;\n    /// @dev The timestamp that scheduled to revoke the candidate (no schedule=0)\n    uint256 revokingTimestamp;\n    /// @dev The deadline that the candidate must top up staking amount to keep it larger than or equal to the threshold (no deadline=0)\n    uint256 topupDeadline;\n  }\n\n  struct CommissionSchedule {\n    /// @dev The timestamp that the commission schedule gets affected (no schedule=0).\n    uint256 effectiveTimestamp;\n    /// @dev The new commission rate. Value is in range [0; 100_00], stands for 0-100%\n    uint256 commissionRate;\n  }\n\n  /// @dev Emitted when the maximum number of validator candidates is updated.\n  event MaxValidatorCandidateUpdated(uint256 threshold);\n  /// @dev Emitted when the min offset to the effective date of commission rate change is updated.\n  event MinEffectiveDaysOnwardsUpdated(uint256 numOfDays);\n  /// @dev Emitted when the validator candidate is granted.\n  event CandidateGranted(address indexed cid, address indexed treasuryAddr, address indexed admin);\n  /// @dev Emitted when the revoking timestamp of a candidate is updated.\n  event CandidateRevokingTimestampUpdated(address indexed cid, uint256 revokingTimestamp);\n  /// @dev Emitted when the topup deadline of a candidate is updated.\n  event CandidateTopupDeadlineUpdated(address indexed cid, uint256 topupDeadline);\n  /// @dev Emitted when the validator candidate is revoked.\n  event CandidatesRevoked(address[] cids);\n\n  /// @dev Emitted when the commission rate of a validator is updated.\n  event CommissionRateUpdated(address indexed cid, uint256 rate);\n  /// @dev Error of exceeding maximum number of candidates.\n  error ErrExceedsMaxNumberOfCandidate();\n  /// @dev Error of querying for already existent candidate.\n  error ErrExistentCandidate();\n  /// @dev Error of querying for non-existent candidate.\n  error ErrNonExistentCandidate();\n  /// @dev Error of candidate admin already exists.\n  error ErrExistentCandidateAdmin(address candidateAdminAddr);\n  /// @dev Error of treasury already exists.\n  error ErrExistentTreasury(address treasuryAddr);\n  /// @dev Error of invalid commission rate.\n  error ErrInvalidCommissionRate();\n  /// @dev Error of invalid min effective days onwards.\n  error ErrInvalidMinEffectiveDaysOnwards();\n\n  /**\n   * @dev Returns the maximum number of validator candidate.\n   */\n  function maxValidatorCandidate() external view returns (uint256);\n\n  /**\n   * @dev Returns the minimum number of days to the effective date of commission rate change.\n   */\n  function minEffectiveDaysOnward() external view returns (uint256);\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function setMaxValidatorCandidate(uint256) external;\n\n  /**\n   * @dev Sets the minimum number of days to the effective date of commision rate change.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external;\n\n  /**\n   * @dev Returns whether the address is a validator (candidate).\n   */\n  function isValidatorCandidate(TConsensus consensus) external view returns (bool);\n\n  /**\n   * @dev Returns the list validator candidates.\n   */\n  function getValidatorCandidates() external view returns (TConsensus[] memory);\n\n  /**\n   * @dev Returns the list of validator candidate ids.\n   */\n  function getValidatorCandidateIds() external view returns (address[] memory);\n\n  /**\n   * @dev Returns all candidate info.\n   */\n  function getCandidateInfos() external view returns (ValidatorCandidate[] memory);\n\n  /**\n   * @dev Returns the info of a candidate.\n   */\n  function getCandidateInfo(TConsensus consensus) external view returns (ValidatorCandidate memory);\n\n  /**\n   * @dev Returns whether the address is the candidate admin.\n   */\n  function isCandidateAdmin(TConsensus consensus, address admin) external view returns (bool);\n\n  /**\n   * @dev Returns the schedule of changing commission rate of a candidate address.\n   */\n  function getCommissionChangeSchedule(TConsensus consensus) external view returns (CommissionSchedule memory);\n}\n"
    },
    "contracts/interfaces/validator/ICandidateManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { TConsensus } from \"../../udvts/Types.sol\";\n\ninterface ICandidateManagerCallback {\n  /// @dev Emitted when a schedule for updating commission rate is set.\n  event CommissionRateUpdateScheduled(address indexed cid, uint256 effectiveTimestamp, uint256 rate);\n  /// @dev Error of already requested revoking candidate before.\n  error ErrAlreadyRequestedRevokingCandidate();\n  /// @dev Error of commission change schedule exists.\n  error ErrAlreadyRequestedUpdatingCommissionRate();\n  /// @dev Error of trusted org cannot renounce.\n  error ErrTrustedOrgCannotRenounce();\n  /// @dev Error of invalid effective days onwards.\n  error ErrInvalidEffectiveDaysOnwards();\n\n  /**\n   * @dev Grants a validator candidate.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateGranted`.\n   *\n   */\n  function execApplyValidatorCandidate(\n    address candidateAdmin,\n    address cid,\n    address payable treasuryAddr,\n    uint256 commissionRate\n  ) external;\n\n  /**\n   * @dev Requests to revoke a validator candidate in next `secsLeft` seconds.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   * Emits the event `CandidateRevokingTimestampUpdated`.\n   *\n   */\n  function execRequestRenounceCandidate(address cid, uint256 secsLeft) external;\n\n  /**\n   * @dev Fallback function of `CandidateStaking-requestUpdateCommissionRate`.\n   *\n   * Requirements:\n   * - The method caller is the staking contract.\n   * - The `effectiveTimestamp` must be the beginning of a UTC day, and at least from 7 days onwards\n   * - The `rate` must be in range of [0_00; 100_00].\n   *\n   * Emits the event `CommissionRateUpdateScheduled`.\n   *\n   */\n  function execRequestUpdateCommissionRate(address cid, uint256 effectiveTimestamp, uint256 rate) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeAdminAddress`.\n   * This updates the shadow storage slot of \"shadowedAdmin\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeAdminAddress(address cid, address newAdmin) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeConsensusAddress`.\n   * This updates the shadow storage slot of \"shadowedConsensus\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeConsensusAddress(address cid, TConsensus newConsensus) external;\n\n  /**\n   * @dev Fallback function of `Profile-requestChangeTreasuryAddress`.\n   * This updates the shadow storage slot of \"shadowedTreasury\" for candidate id `id` to `newAdmin`.\n   *\n   * Requirements:\n   * - The caller must be the Profile contract.\n   */\n  function execChangeTreasuryAddress(address cid, address payable newTreasury) external;\n}\n"
    },
    "contracts/interfaces/validator/ICoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ISlashingExecution.sol\";\n\ninterface ICoinbaseExecution is ISlashingExecution {\n  enum BlockRewardDeprecatedType {\n    UNKNOWN,\n    UNAVAILABILITY,\n    AFTER_BAILOUT\n  }\n\n  /// @dev Emitted when the validator set is updated\n  event ValidatorSetUpdated(uint256 indexed period, address[] cids);\n  /// @dev Emitted when the bridge operator set is updated, to mirror the in-jail and maintaining status of the validator.\n  event BlockProducerSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] cids);\n  /// @dev Emitted when the bridge operator set is updated.\n  event BridgeOperatorSetUpdated(uint256 indexed period, uint256 indexed epoch, address[] bridgeOperators);\n\n  /// @dev Emitted when the reward of the block producer is deprecated.\n  event BlockRewardDeprecated(\n    address indexed cid,\n    uint256 rewardAmount,\n    BlockRewardDeprecatedType deprecatedType\n  );\n  /// @dev Emitted when the block reward is submitted.\n  event BlockRewardSubmitted(address indexed cid, uint256 submittedAmount, uint256 bonusAmount);\n\n  /// @dev Emitted when the block producer reward is distributed.\n  event MiningRewardDistributed(address indexed cid, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the block producer reward.\n  event MiningRewardDistributionFailed(\n    address indexed cid,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the bridge operator reward is distributed.\n  event BridgeOperatorRewardDistributed(\n    address indexed cid,\n    address indexed bridgeOperator,\n    address indexed recipientAddr,\n    uint256 amount\n  );\n  /// @dev Emitted when the contract fails when distributing the bridge operator reward.\n  event BridgeOperatorRewardDistributionFailed(\n    address indexed cid,\n    address indexed bridgeOperator,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the fast finality reward is distributed.\n  event FastFinalityRewardDistributed(address indexed cid, address indexed recipient, uint256 amount);\n  /// @dev Emitted when the contract fails when distributing the fast finality reward.\n  event FastFinalityRewardDistributionFailed(\n    address indexed cid,\n    address indexed recipient,\n    uint256 amount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the amount of RON reward is distributed to staking contract.\n  event StakingRewardDistributed(uint256 totalAmount, address[] consensusAddrs, uint256[] amounts);\n  /// @dev Emitted when the contracts fails when distributing the amount of RON to the staking contract.\n  event StakingRewardDistributionFailed(\n    uint256 totalAmount,\n    address[] consensusAddrs,\n    uint256[] amounts,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the epoch is wrapped up.\n  event WrappedUpEpoch(uint256 indexed periodNumber, uint256 indexed epochNumber, bool periodEnding);\n\n  /// @dev Error of only allowed at the end of epoch\n  error ErrAtEndOfEpochOnly();\n  /// @dev Error of query for already wrapped up epoch\n  error ErrAlreadyWrappedEpoch();\n\n  /**\n   * @dev Submits reward of the current block.\n   *\n   * Requirements:\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDeprecated` if the coinbase is slashed or no longer be a block producer.\n   * Emits the event `BlockRewardSubmitted` for the valid call.\n   *\n   */\n  function submitBlockReward() external payable;\n\n  /**\n   * @dev Wraps up the current epoch.\n   *\n   * Requirements:\n   * - The method must be called when the current epoch is ending.\n   * - The epoch is not wrapped yet.\n   * - The method caller is coinbase.\n   *\n   * Emits the event `MiningRewardDistributed` when some validator has reward distributed.\n   * Emits the event `StakingRewardDistributed` when some staking pool has reward distributed.\n   * Emits the event `BlockProducerSetUpdated` when the epoch is wrapped up.\n   * Emits the event `BridgeOperatorSetUpdated` when the epoch is wrapped up at period ending.\n   * Emits the event `ValidatorSetUpdated` when the epoch is wrapped up at period ending, and the validator set gets updated.\n   * Emits the event `WrappedUpEpoch`.\n   *\n   */\n  function wrapUpEpoch() external payable;\n}\n"
    },
    "contracts/interfaces/validator/IEmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface IEmergencyExit {\n  /// @dev Emitted when the fund is locked from an emergency exit request\n  event EmergencyExitRequested(address indexed cid, uint256 lockedAmount);\n  /// @dev Emitted when the fund that locked from an emergency exit request is transferred to the recipient.\n  event EmergencyExitLockedFundReleased(\n    address indexed cid,\n    address indexed recipient,\n    uint256 unlockedAmount\n  );\n  /// @dev Emitted when the fund that locked from an emergency exit request is failed to transferred back.\n  event EmergencyExitLockedFundReleasingFailed(\n    address indexed cid,\n    address indexed recipient,\n    uint256 unlockedAmount,\n    uint256 contractBalance\n  );\n\n  /// @dev Emitted when the emergency exit locked amount is updated.\n  event EmergencyExitLockedAmountUpdated(uint256 amount);\n  /// @dev Emitted when the emergency expiry duration is updated.\n  event EmergencyExpiryDurationUpdated(uint256 amount);\n\n  /// @dev Error of already requested emergency exit before.\n  error ErrAlreadyRequestedEmergencyExit();\n  /// @dev Error thrown when the info of releasing locked fund not exist.\n  error ErrLockedFundReleaseInfoNotFound(address cid);\n  /// @dev Error thrown when the the locked fund of emergency exit might be recycled.\n  error ErrLockedFundMightBeRecycled(address cid);\n\n  /**\n   * @dev Returns the amount of RON to lock from a consensus address.\n   */\n  function emergencyExitLockedAmount() external returns (uint256);\n\n  /**\n   * @dev Returns the duration that an emergency request is expired and the fund will be recycled.\n   */\n  function emergencyExpiryDuration() external returns (uint256);\n\n  /**\n   * @dev Sets the amount of RON to lock from a consensus address.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedAmountUpdated`.\n   *\n   */\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external;\n\n  /**\n   * @dev Sets the duration that an emergency request is expired and the fund will be recycled.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExpiryDurationUpdated`.\n   *\n   */\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external;\n\n  /**\n   * @dev Unlocks fund for emergency exit request.\n   *\n   * Requirements:\n   * - The method caller is admin.\n   *\n   * Emits the event `EmergencyExitLockedFundReleased` if the fund is successfully unlocked.\n   * Emits the event `EmergencyExitLockedFundReleasingFailed` if the fund is failed to unlock.\n   *\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address validatorId, address payable recipient) external;\n\n  /**\n   * @dev Fallback function of `IStaking-requestEmergencyExit`.\n   *\n   * Requirements:\n   * - The method caller is staking contract.\n   *\n   */\n  function execRequestEmergencyExit(address validatorId, uint256 secLeftToRevoke) external;\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ICommonInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./IJailingInfo.sol\";\nimport \"./ITimingInfo.sol\";\nimport \"./IValidatorInfoV2.sol\";\n\ninterface ICommonInfo is ITimingInfo, IJailingInfo, IValidatorInfoV2 {\n  struct EmergencyExitInfo {\n    uint256 lockedAmount;\n    // The timestamp that this locked amount will be recycled to staking vesting contract\n    uint256 recyclingAt;\n  }\n\n  /// @dev Emitted when the deprecated reward is withdrawn.\n  event DeprecatedRewardRecycled(address indexed recipientAddr, uint256 amount);\n  /// @dev Emitted when the deprecated reward withdrawal is failed\n  event DeprecatedRewardRecycleFailed(address indexed recipientAddr, uint256 amount, uint256 balance);\n\n  /// @dev Error thrown when receives RON from neither staking vesting contract nor staking contract\n  error ErrUnauthorizedReceiveRON();\n  /// @dev Error thrown when queries for a non existent info.\n  error NonExistentRecyclingInfo();\n\n  /**\n   * @dev Returns the total deprecated reward, which includes reward that is not sent for slashed validators and unsastified bridge operators\n   */\n  function totalDeprecatedReward() external view returns (uint256);\n\n  /**\n   * @dev Returns the emergency exit request.\n   */\n  function getEmergencyExitInfo(TConsensus consensus) external view returns (EmergencyExitInfo memory);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IJailingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../udvts/Types.sol\";\n\ninterface IJailingInfo {\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkJailed(TConsensus) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeft(\n    TConsensus addr\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validator are put in jail (cannot join the set of validators) at a specific block.\n   */\n  function checkJailedAtBlock(TConsensus addr, uint256 blockNum) external view returns (bool);\n\n  /**\n   * @dev Returns whether the validator are put in jail at a specific block and the number of block and epoch that he still is in the jail.\n   */\n  function getJailedTimeLeftAtBlock(\n    TConsensus addr,\n    uint256 blockNum\n  ) external view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_);\n\n  /**\n   * @dev Returns whether the validators are put in jail (cannot join the set of validators) during the current period.\n   */\n  function checkManyJailed(TConsensus[] calldata) external view returns (bool[] memory);\n\n  function checkManyJailedById(address[] calldata candidateIds) external view returns (bool[] memory);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during the current period.\n   */\n  function checkMiningRewardDeprecated(TConsensus addr) external view returns (bool);\n\n  /**\n   * @dev Returns whether the incoming reward of the block producer is deprecated during a specific period.\n   */\n  function checkMiningRewardDeprecatedAtPeriod(TConsensus addr, uint256 period) external view returns (bool);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/ITimingInfo.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ITimingInfo {\n  /**\n   * @dev Returns the block that validator set was updated.\n   */\n  function getLastUpdatedBlock() external view returns (uint256);\n\n  /**\n   * @dev Returns the number of blocks in a epoch.\n   */\n  function numberOfBlocksInEpoch() external view returns (uint256 _numberOfBlocks);\n\n  /**\n   * @dev Returns the epoch index from the block number.\n   */\n  function epochOf(uint256 _block) external view returns (uint256);\n\n  /**\n   * @dev Returns whether the epoch ending is at the block number `_block`.\n   */\n  function epochEndingAt(uint256 _block) external view returns (bool);\n\n  /**\n   * @dev Tries to get the period index from the epoch number.\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber);\n\n  /**\n   * @dev Returns whether the period ending at the current block number.\n   */\n  function isPeriodEnding() external view returns (bool);\n\n  /**\n   * @dev Returns the period index from the current block.\n   */\n  function currentPeriod() external view returns (uint256);\n\n  /**\n   * @dev Returns the block number that the current period starts at.\n   */\n  function currentPeriodStartAtBlock() external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/validator/info-fragments/IValidatorInfoV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { TConsensus } from \"../../../udvts/Types.sol\";\n\ninterface IValidatorInfoV2 {\n  /// @dev Error thrown when an invalid maximum prioritized validator number is provided.\n  error ErrInvalidMaxPrioritizedValidatorNumber();\n  /// @dev Emitted when the number of max validator is updated.\n  event MaxValidatorNumberUpdated(uint256);\n  /// @dev Emitted when the number of reserved slots for prioritized validators is updated.\n  event MaxPrioritizedValidatorNumberUpdated(uint256);\n\n  /**\n   * @dev Returns the maximum number of validators in the epoch.\n   */\n  function maxValidatorNumber() external view returns (uint256 _maximumValidatorNumber);\n\n  /**\n   * @dev Returns the number of reserved slots for prioritized validators.\n   */\n  function maxPrioritizedValidatorNumber() external view returns (uint256 _maximumPrioritizedValidatorNumber);\n\n  /**\n   * @dev Returns the current validator list.\n   */\n  function getValidators() external view returns (TConsensus[] memory validatorList);\n\n  /**\n   * @dev Returns the ids of current validator list.\n   */\n  function getValidatorIds() external view returns (address[] memory cids);\n\n  /**\n   * @dev Returns the current block producer list.\n   */\n  function getBlockProducers() external view returns (TConsensus[] memory consensusList);\n\n  /**\n   * @dev Returns the ids current block producer list.\n   */\n  function getBlockProducerIds() external view returns (address[] memory cids);\n\n  /**\n   * @dev Returns whether the address is block producer or not.\n   */\n  function isBlockProducer(TConsensus consensusAddr) external view returns (bool);\n\n  /**\n   * @dev Returns total numbers of the block producers.\n   */\n  function totalBlockProducer() external view returns (uint256);\n\n  /**\n   * @dev Updates the max validator number\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxValidatorNumberUpdated`\n   *\n   */\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external;\n\n  /**\n   * @dev Updates the number of reserved slots for prioritized validators\n   *\n   * Requirements:\n   * - The method caller is admin\n   *\n   * Emits the event `MaxPrioritizedValidatorNumberUpdated`\n   *\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external;\n}\n"
    },
    "contracts/interfaces/validator/IRoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./ICandidateManager.sol\";\nimport \"./ICandidateManagerCallback.sol\";\nimport \"./info-fragments/ICommonInfo.sol\";\nimport \"./ICoinbaseExecution.sol\";\nimport \"./ISlashingExecution.sol\";\nimport \"./IEmergencyExit.sol\";\n\ninterface IRoninValidatorSet is\n  ICandidateManagerCallback,\n  ICandidateManager,\n  ICommonInfo,\n  ISlashingExecution,\n  ICoinbaseExecution,\n  IEmergencyExit\n{}\n"
    },
    "contracts/interfaces/validator/ISlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\ninterface ISlashingExecution {\n  /// @dev Emitted when the validator is punished.\n  event ValidatorPunished(\n    address indexed cid,\n    uint256 indexed period,\n    uint256 jailedUntil,\n    uint256 deductedStakingAmount,\n    bool blockProducerRewardDeprecated,\n    bool bridgeOperatorRewardDeprecated\n  );\n  /// @dev Emitted when the validator get out of jail by bailout.\n  event ValidatorUnjailed(address indexed cid, uint256 period);\n\n  /// @dev Error of cannot bailout due to high tier slash.\n  error ErrCannotBailout(address validator);\n\n  /**\n   * @dev Finalize the slash request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorPunished`.\n   *\n   */\n  function execSlash(address cid, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external;\n\n  /**\n   * @dev Finalize the bailout request from slash indicator contract.\n   *\n   * Requirements:\n   * - The method caller is slash indicator contract.\n   *\n   * Emits the event `ValidatorUnjailed`.\n   *\n   */\n  function execBailOut(address cid, uint256 period) external;\n}\n"
    },
    "contracts/libraries/AddressArrayUtils.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary AddressArrayUtils {\n  /**\n   * @dev Error thrown when a duplicated element is detected in an array.\n   * @param msgSig The function signature that invoke the error.\n   */\n  error ErrDuplicated(bytes4 msgSig);\n\n  /**\n   * @dev Returns whether or not there's a duplicate. Runs in O(n^2).\n   * @param A Array to search\n   * @return Returns true if duplicate, false otherwise\n   */\n  function hasDuplicate(address[] memory A) internal pure returns (bool) {\n    if (A.length == 0) {\n      return false;\n    }\n    unchecked {\n      for (uint256 i = 0; i < A.length - 1; i++) {\n        for (uint256 j = i + 1; j < A.length; j++) {\n          if (A[i] == A[j]) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * @dev Returns whether two arrays of addresses are equal or not.\n   */\n  function isEqual(address[] memory _this, address[] memory _other) internal pure returns (bool yes_) {\n    // Hashing two arrays and compare their hash\n    assembly {\n      let _thisHash := keccak256(add(_this, 32), mul(mload(_this), 32))\n      let _otherHash := keccak256(add(_other, 32), mul(mload(_other), 32))\n      yes_ := eq(_thisHash, _otherHash)\n    }\n  }\n\n  /**\n   * @dev Return the concatenated array from a and b.\n   */\n  function extend(address[] memory a, address[] memory b) internal pure returns (address[] memory c) {\n    uint256 lengthA = a.length;\n    uint256 lengthB = b.length;\n    unchecked {\n      c = new address[](lengthA + lengthB);\n    }\n    uint256 i;\n    for (; i < lengthA; ) {\n      c[i] = a[i];\n      unchecked {\n        ++i;\n      }\n    }\n    for (uint256 j; j < lengthB; ) {\n      c[i] = b[j];\n      unchecked {\n        ++i;\n        ++j;\n      }\n    }\n  }\n}\n"
    },
    "contracts/libraries/EnumFlags.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This library implements checking flag of an enumerated value.\n * The originated idea is inherited from [Enum.HashFlag(Enum)](https://learn.microsoft.com/en-us/dotnet/api/system.enum.hasflag?view=net-6.0) method of C#.\n */\nlibrary EnumFlags {\n  enum ValidatorFlag {\n    None, // bit(00)\n    BlockProducer, // bit(01)\n    DeprecatedBridgeOperator, // bit(10)\n    Both // bit(11)\n  }\n\n  function isNone(ValidatorFlag _value) internal pure returns (bool) {\n    return uint8(_value) == 0;\n  }\n\n  /**\n   * @dev Checks if `_value` has `_flag`.\n   */\n  function hasFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (bool) {\n    return (uint8(_value) & uint8(_flag)) != 0;\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after adding `_flag`.\n   */\n  function addFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) | uint8(_flag));\n  }\n\n  /**\n   * @dev Calculate new value of `_value` after remove `_flag`.\n   */\n  function removeFlag(ValidatorFlag _value, ValidatorFlag _flag) internal pure returns (ValidatorFlag) {\n    return ValidatorFlag(uint8(_value) & ~uint8(_flag));\n  }\n}\n"
    },
    "contracts/libraries/Math.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Math {\n  /**\n   * @dev Returns the largest of two numbers.\n   */\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a >= b ? a : b;\n  }\n\n  /**\n   * @dev Returns the smallest of two numbers.\n   */\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a < b ? a : b;\n  }\n\n  /**\n   * @dev Returns whether the number `c` is in range of [a; b].\n   */\n  function inRange(uint256 c, uint256 a, uint256 b) internal pure returns (bool) {\n    return a <= c && c <= b;\n  }\n\n  /**\n   * @dev Returns whether two inclusive ranges [x1;x2] and [y1;y2] overlap.\n   */\n  function twoRangeOverlap(uint256 x1, uint256 x2, uint256 y1, uint256 y2) internal pure returns (bool) {\n    return x1 <= y2 && y1 <= x2;\n  }\n\n  /**\n   * @dev Returns value of a + b; in case result is larger than upperbound, upperbound is returned.\n   */\n  function addWithUpperbound(uint256 a, uint256 b, uint256 upperbound) internal pure returns (uint256) {\n    return min(a + b, upperbound);\n  }\n\n  /**\n   * @dev Returns value of a - b; in case of negative result, 0 is returned.\n   */\n  function subNonNegative(uint256 a, uint256 b) internal pure returns (uint256) {\n    return a > b ? a - b : 0;\n  }\n\n  /**\n   * @dev Returns value of `a + zeroable` if zerobale is not 0; otherwise, return 0.\n   */\n  function addIfNonZero(uint256 a, uint256 zeroable) internal pure returns (uint256) {\n    return zeroable != 0 ? a + zeroable : 0;\n  }\n}\n"
    },
    "contracts/mocks/libraries/Sorting.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.0;\n\nlibrary Sorting {\n  struct Node {\n    uint key;\n    uint value;\n  }\n\n  struct Node3 {\n    uint key;\n    uint value;\n    uint otherKey;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   VALUE SORTING                                   //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(uint[] memory data) internal pure returns (uint[] memory) {\n    return _quickSort(data, int(0), int(data.length - 1));\n  }\n\n  function _quickSort(uint[] memory arr, int left, int right) private pure returns (uint[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return arr;\n    uint pivot = arr[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (arr[uint(i)] > pivot) i++;\n      while (pivot > arr[uint(j)]) j--;\n      if (i <= j) {\n        (arr[uint(i)], arr[uint(j)]) = (arr[uint(j)], arr[uint(i)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) arr = _quickSort(arr, left, j);\n    if (i < right) arr = _quickSort(arr, i, right);\n\n    return arr;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                   NODE SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sort(address[] memory _keys, uint256[] memory _values) internal pure returns (address[] memory) {\n    require(_values.length == _keys.length, \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return _keys;\n    }\n\n    Node[] memory _nodes = new Node[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(uint256(uint160(_keys[_i])), _values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return _keys;\n  }\n\n  function sort(uint256[] memory keys, uint256[] memory values) internal pure returns (uint256[] memory) {\n    require(values.length == keys.length, \"Sorting: invalid array length\");\n    if (keys.length == 0) {\n      return keys;\n    }\n\n    Node[] memory _nodes = new Node[](keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node(keys[_i], values[_i]);\n    }\n    _quickSortNodes(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      keys[_i] = _nodes[_i].key; // Casting?\n    }\n\n    return keys;\n  }\n\n  function sortNodes(Node[] memory nodes) internal pure returns (Node[] memory) {\n    return _quickSortNodes(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNodes(Node[] memory nodes, int left, int right) private pure returns (Node[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNodes(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNodes(nodes, left, j);\n    if (i < right) nodes = _quickSortNodes(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNodes(Node[] memory nodes) private pure returns (Node[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNodes(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNodes(Node memory x, Node memory y) private pure returns (Node memory, Node memory) {\n    Node memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////////////\n  //                                  NODE3 SORTING                                    //\n  ///////////////////////////////////////////////////////////////////////////////////////\n\n  function sortWithExternalKeys(\n    address[] memory _keys,\n    uint256[] memory _values,\n    uint256[] memory _otherKeys\n  ) internal pure returns (address[] memory keys_, uint256[] memory otherKeys_) {\n    require((_values.length == _keys.length) && (_otherKeys.length == _keys.length), \"Sorting: invalid array length\");\n    if (_keys.length == 0) {\n      return (_keys, _otherKeys);\n    }\n\n    Node3[] memory _nodes = new Node3[](_keys.length);\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _nodes[_i] = Node3(uint256(uint160(_keys[_i])), _values[_i], _otherKeys[_i]);\n    }\n    _quickSortNode3s(_nodes, int(0), int(_nodes.length - 1));\n\n    for (uint256 _i; _i < _nodes.length; _i++) {\n      _keys[_i] = address(uint160(_nodes[_i].key)); // Casting?\n    }\n\n    return (_keys, _otherKeys);\n  }\n\n  function sortNode3s(Node3[] memory nodes) internal pure returns (Node3[] memory) {\n    return _quickSortNode3s(nodes, int(0), int(nodes.length - 1));\n  }\n\n  function _quickSortNode3s(Node3[] memory nodes, int left, int right) private pure returns (Node3[] memory) {\n    int i = left;\n    int j = right;\n    if (i == j) return nodes;\n    Node3 memory pivot = nodes[uint(left + (right - left) / 2)];\n    while (i <= j) {\n      while (nodes[uint(i)].value > pivot.value) i++;\n      while (pivot.value > nodes[uint(j)].value) j--;\n      if (i <= j) {\n        (nodes[uint(i)], nodes[uint(j)]) = __swapNode3s(nodes[uint(i)], nodes[uint(j)]);\n        i++;\n        j--;\n      }\n    }\n    if (left < j) nodes = _quickSortNode3s(nodes, left, j);\n    if (i < right) nodes = _quickSortNode3s(nodes, i, right);\n\n    return nodes;\n  }\n\n  function _bubbleSortNode3s(Node3[] memory nodes) private pure returns (Node3[] memory) {\n    uint length = nodes.length;\n    for (uint i = 0; i < length - 1; i++) {\n      for (uint j = i + 1; j < length; j++) {\n        if (nodes[j].value > nodes[i].value) {\n          (nodes[i], nodes[j]) = __swapNode3s(nodes[i], nodes[j]);\n        }\n      }\n    }\n    return nodes;\n  }\n\n  function __swapNode3s(Node3 memory x, Node3 memory y) private pure returns (Node3 memory, Node3 memory) {\n    Node3 memory tmp = x;\n    (x, y) = (y, tmp);\n    return (x, y);\n  }\n}\n"
    },
    "contracts/mocks/MockPrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./libraries/Sorting.sol\";\nimport \"../libraries/Math.sol\";\n\ncontract MockPrecompile {\n  function sortValidators(\n    address[] memory _validators,\n    uint256[] memory _weights\n  ) public pure returns (address[] memory) {\n    return Sorting.sort(_validators, _weights);\n  }\n\n  function validatingDoubleSignProof(\n    address /*consensusAddr*/,\n    bytes calldata /*_header1*/,\n    bytes calldata /*_header2*/\n  ) public pure returns (bool _validEvidence) {\n    return true;\n  }\n\n  function validateFinalityVoteProof(\n    bytes calldata,\n    uint256,\n    bytes32[2] calldata,\n    bytes[][2] calldata,\n    bytes[2] calldata\n  ) public pure returns (bool) {\n    return true;\n  }\n\n  function pickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) public pure returns (address[] memory _result) {\n    (_result, _trustedWeights) = Sorting.sortWithExternalKeys(_candidates, _weights, _trustedWeights);\n    uint256 _newValidatorCount = Math.min(_maxValidatorNumber, _result.length);\n    _arrangeValidatorCandidates(_result, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n  }\n\n  function validateProofOfPossession(\n    bytes calldata /*publicKey*/,\n    bytes calldata /*proofOfPossession*/\n  ) public pure returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Arranges the sorted candidates to list of validators, by asserting prioritized and non-prioritized candidates\n   *\n   * @param _candidates A sorted list of candidates\n   */\n  function _arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) internal pure {\n    address[] memory _waitingCandidates = new address[](_candidates.length);\n    uint _waitingCounter;\n    uint _prioritySlotCounter;\n\n    for (uint _i = 0; _i < _candidates.length; _i++) {\n      if (_trustedWeights[_i] > 0 && _prioritySlotCounter < _maxPrioritizedValidatorNumber) {\n        _candidates[_prioritySlotCounter++] = _candidates[_i];\n        continue;\n      }\n      _waitingCandidates[_waitingCounter++] = _candidates[_i];\n    }\n\n    _waitingCounter = 0;\n    for (uint _i = _prioritySlotCounter; _i < _newValidatorCount; _i++) {\n      _candidates[_i] = _waitingCandidates[_waitingCounter++];\n    }\n\n    assembly {\n      mstore(_candidates, _newValidatorCount)\n    }\n  }\n}\n"
    },
    "contracts/mocks/MockProfile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockPrecompile.sol\";\nimport \"../ronin/slash-indicator/SlashIndicator.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../ronin/profile/Profile.sol\";\n\ncontract MockProfile is Profile {\n  bool internal _verificationFailed;\n\n  function setVerificationFailed(bool _failed) external {\n    _verificationFailed = _failed;\n  }\n\n  function _pcVerifyBLSPublicKey(\n    bytes calldata /*publicKey*/,\n    bytes calldata /*proofOfPossession*/\n  ) internal view override returns (bool) {\n    return !_verificationFailed;\n  }\n}\n"
    },
    "contracts/mocks/MockSlashIndicatorExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockPrecompile.sol\";\nimport \"../ronin/slash-indicator/SlashIndicator.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\n\ncontract MockSlashIndicatorExtended is SlashIndicator, MockPrecompile {\n  function slashFelony(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function slashMisdemeanor(address _validatorAddr) external {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execSlash(_validatorAddr, 0, 0, false);\n  }\n\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal pure override returns (bool _validEvidence) {\n    return validatingDoubleSignProof(_consensusAddr, _header1, _header2);\n  }\n}\n"
    },
    "contracts/mocks/validator/MockRoninValidatorSetExtended.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./MockRoninValidatorSetOverridePrecompile.sol\";\nimport \"../../libraries/EnumFlags.sol\";\n\ncontract MockRoninValidatorSetExtended is MockRoninValidatorSetOverridePrecompile {\n  bool private _initialized;\n  uint256[] internal _epochs;\n\n  constructor() {}\n\n  function initEpoch() public {\n    if (!_initialized) {\n      _epochs.push(0);\n      _initialized = true;\n    }\n  }\n\n  function endEpoch() external {\n    _epochs.push(block.number);\n  }\n\n  function epochOf(uint256 _block) public view override returns (uint256 _epoch) {\n    for (uint256 _i = _epochs.length; _i > 0; _i--) {\n      if (_block > _epochs[_i - 1]) {\n        return _i;\n      }\n    }\n  }\n\n  function epochEndingAt(uint256 _block) public view override(ITimingInfo, TimingStorage) returns (bool) {\n    for (uint _i = 0; _i < _epochs.length; _i++) {\n      if (_block == _epochs[_i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function getJailUntils(address[] calldata _addrs) public view returns (uint256[] memory jailUntils_) {\n    jailUntils_ = new uint256[](_addrs.length);\n    for (uint _i = 0; _i < _addrs.length; _i++) {\n      jailUntils_[_i] = _blockProducerJailedBlock[_addrs[_i]];\n    }\n  }\n\n  function addValidators(address[] calldata _addrs) public {\n    for (uint _i = 0; _i < _addrs.length; _i++) {\n      address _cAddr = _addrs[_i];\n      _validatorIds[_i] = _cAddr;\n      _validatorMap[_cAddr] = EnumFlags.ValidatorFlag.Both;\n    }\n  }\n}\n"
    },
    "contracts/mocks/validator/MockRoninValidatorSetOverridePrecompile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../MockPrecompile.sol\";\nimport \"../../ronin/validator/RoninValidatorSet.sol\";\n\ncontract MockRoninValidatorSetOverridePrecompile is RoninValidatorSet, MockPrecompile {\n  constructor() {}\n\n  function arrangeValidatorCandidates(\n    address[] memory _candidates,\n    uint256[] memory _trustedWeights,\n    uint _newValidatorCount,\n    uint _maxPrioritizedValidatorNumber\n  ) external pure returns (address[] memory) {\n    _arrangeValidatorCandidates(_candidates, _trustedWeights, _newValidatorCount, _maxPrioritizedValidatorNumber);\n    return _candidates;\n  }\n\n  function _pcSortCandidates(\n    address[] memory _candidates,\n    uint256[] memory _weights\n  ) internal pure override returns (address[] memory _result) {\n    return sortValidators(_candidates, _weights);\n  }\n\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal pure override returns (address[] memory _result, uint256 _newValidatorCount) {\n    _result = pickValidatorSet(\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/mocks/validator/MockValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../ronin/validator/CandidateManagerCallback.sol\";\nimport { HasStakingVestingDeprecated, HasSlashIndicatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\ncontract MockValidatorSet is\n  IRoninValidatorSet,\n  CandidateManagerCallback,\n  HasStakingVestingDeprecated,\n  HasSlashIndicatorDeprecated\n{\n  uint256 internal _lastUpdatedPeriod;\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev Mapping from period number => slashed\n  mapping(uint256 => bool) internal _periodSlashed;\n\n  constructor(\n    address _stakingContract,\n    address _slashIndicatorContract,\n    address _stakingVestingContract,\n    address _profileContract,\n    uint256 __maxValidatorCandidate,\n    uint256 __numberOfBlocksInEpoch,\n    uint256 __minEffectiveDaysOnwards\n  ) {\n    _setContract(ContractType.STAKING, _stakingContract);\n    _setContract(ContractType.SLASH_INDICATOR, _slashIndicatorContract);\n    _setContract(ContractType.STAKING_VESTING, _stakingVestingContract);\n    _setContract(ContractType.PROFILE, _profileContract);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n    _minEffectiveDaysOnwards = __minEffectiveDaysOnwards;\n  }\n\n  function submitBlockReward() external payable override {}\n\n  function wrapUpEpoch() external payable override {\n    _syncCandidateSet(_lastUpdatedPeriod + 1);\n    _lastUpdatedPeriod = currentPeriod();\n  }\n\n  function getLastUpdatedBlock() external view override returns (uint256) {}\n\n  function checkManyJailed(TConsensus[] calldata) external view override returns (bool[] memory) {}\n\n  function checkManyJailedById(address[] calldata candidateIds) external view returns (bool[] memory) {}\n\n  function checkMiningRewardDeprecated(TConsensus) external view override returns (bool) {}\n\n  function checkMiningRewardDeprecatedAtPeriod(TConsensus, uint256 period) external view override returns (bool) {}\n\n  function checkBridgeRewardDeprecatedAtPeriod(\n    TConsensus _consensusAddr,\n    uint256 _period\n  ) external view returns (bool _result) {}\n\n  function epochOf(uint256 _block) external view override returns (uint256) {}\n\n  function getValidators() external view override returns (TConsensus[] memory) {}\n\n  function getValidatorIds() external view override returns (address[] memory) {}\n\n  function epochEndingAt(uint256 _block) external view override returns (bool) {}\n\n  function execSlash(address cid, uint256 newJailedUntil, uint256 slashAmount, bool cannotBailout) external override {}\n\n  function execBailOut(address, uint256) external override {}\n\n  function setMaxValidatorNumber(uint256 _maxValidatorNumber) external override {}\n\n  function setMaxPrioritizedValidatorNumber(uint256 _maxPrioritizedValidatorNumber) external override {}\n\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {}\n\n  function maxPrioritizedValidatorNumber()\n    external\n    view\n    override\n    returns (uint256 _maximumPrioritizedValidatorNumber)\n  {}\n\n  function numberOfBlocksInEpoch() public view override returns (uint256) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  function getBlockProducers() external view override returns (TConsensus[] memory) {}\n\n  function getBlockProducerIds() external view override returns (address[] memory) {}\n\n  function isBlockProducer(TConsensus) external pure override returns (bool) {\n    return true;\n  }\n\n  function totalBlockProducer() external view override returns (uint256) {}\n\n  function tryGetPeriodOfEpoch(uint256) external view returns (bool, uint256) {}\n\n  function isPeriodEnding() public view virtual returns (bool) {\n    return currentPeriod() > _lastUpdatedPeriod;\n  }\n\n  function currentPeriod() public view override returns (uint256) {\n    return block.timestamp / 86400;\n  }\n\n  function checkJailed(TConsensus) external view override returns (bool) {}\n\n  function getJailedTimeLeft(TConsensus) external view override returns (bool, uint256, uint256) {}\n\n  function currentPeriodStartAtBlock() external view override returns (uint256) {}\n\n  function checkJailedAtBlock(TConsensus _addr, uint256 _blockNum) external view override returns (bool) {}\n\n  function getJailedTimeLeftAtBlock(\n    TConsensus _addr,\n    uint256 _blockNum\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {}\n\n  function totalDeprecatedReward() external view override returns (uint256) {}\n\n  function __css2cid(TConsensus consensusAddr) internal view override returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view override returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n\n  function __cid2cssBatch(address[] memory cids) internal view override returns (TConsensus[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyId2Consensus(cids);\n  }\n\n  function execReleaseLockedFundForEmergencyExitRequest(\n    address _candidateId,\n    address payable _recipient\n  ) external override {}\n\n  function emergencyExitLockedAmount() external override returns (uint256) {}\n\n  function emergencyExpiryDuration() external override returns (uint256) {}\n\n  function setEmergencyExitLockedAmount(uint256 _emergencyExitLockedAmount) external override {}\n\n  function setEmergencyExpiryDuration(uint256 _emergencyExpiryDuration) external override {}\n\n  function getEmergencyExitInfo(TConsensus consensus) external view override returns (EmergencyExitInfo memory) {}\n\n  function execRequestEmergencyExit(address, uint256) external {}\n\n  function isOperatingBridge(TConsensus) external view returns (bool) {}\n\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual override returns (bool) {}\n\n  function _isTrustedOrg(address validatorId) internal virtual override returns (bool) {}\n}\n"
    },
    "contracts/multi-chains/RoninTrustedOrganization.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../libraries/AddressArrayUtils.sol\";\nimport \"../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../interfaces/IProfile.sol\";\nimport \"../extensions/collections/HasProxyAdmin.sol\";\nimport \"../extensions/collections/HasContracts.sol\";\nimport \"../udvts/Types.sol\";\n\ncontract RoninTrustedOrganization is IRoninTrustedOrganization, HasProxyAdmin, HasContracts, Initializable {\n  uint256 internal _num;\n  uint256 internal _denom;\n  uint256 internal _totalWeight;\n  uint256 internal _nonce;\n\n  /// @dev Mapping from consensus address => weight\n  mapping(TConsensus => uint256) internal _consensusWeight;\n  /// @dev Mapping from governor address => weight\n  mapping(address => uint256) internal _governorWeight;\n  /// @dev Mapping from bridge voter address => weight\n  mapping(address => uint256) internal __deprecatedBridgeVoterWeight;\n\n  /// @dev Mapping from consensus address => added block\n  mapping(TConsensus => uint256) internal _addedBlock;\n\n  /// @dev Consensus array\n  TConsensus[] internal _consensusList;\n  /// @dev Governors array\n  address[] internal _governorList;\n  /// @dev Bridge voters array\n  address[] internal __deprecatedBridgeVoterList;\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(TrustedOrganization[] calldata trustedOrgs, uint256 num, uint256 denom) external initializer {\n    if (trustedOrgs.length > 0) {\n      _addTrustedOrganizations(trustedOrgs);\n    }\n    _setThreshold(num, denom);\n  }\n\n  function initializeV2(address profileContract) external reinitializer(2) {\n    _setContract(ContractType.PROFILE, profileContract);\n    for (uint i; i < __deprecatedBridgeVoterList.length; ++i) {\n      delete __deprecatedBridgeVoterWeight[__deprecatedBridgeVoterList[i]];\n    }\n    delete __deprecatedBridgeVoterList;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function getThreshold() external view virtual returns (uint256 num_, uint256 denom_) {\n    return (_num, _denom);\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function checkThreshold(uint256 _voteWeight) external view virtual returns (bool) {\n    return _voteWeight * _denom >= _num * _totalWeight;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function minimumVoteWeight() external view virtual returns (uint256) {\n    return (_num * _totalWeight + _denom - 1) / _denom;\n  }\n\n  /**\n   * @inheritdoc IQuorum\n   */\n  function setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) external override onlyAdmin returns (uint256, uint256) {\n    return _setThreshold(_numerator, _denominator);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function addTrustedOrganizations(TrustedOrganization[] calldata _list) external override onlyAdmin {\n    _addTrustedOrganizations(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function updateTrustedOrganizations(TrustedOrganization[] calldata _list) external override onlyAdmin {\n    if (_list.length == 0) revert ErrEmptyArray();\n    for (uint256 _i; _i < _list.length; ) {\n      _updateTrustedOrganization(_list[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit TrustedOrganizationsUpdated(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function removeTrustedOrganizations(TConsensus[] calldata list) external override onlyAdmin {\n    if (list.length == 0) revert ErrEmptyArray();\n\n    for (uint _i = 0; _i < list.length; ) {\n      _removeTrustedOrganization(list[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit TrustedOrganizationsRemoved(list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function totalWeight() external view virtual returns (uint256) {\n    return _totalWeight;\n  }\n\n  function totalWeights() external view returns (uint256) {\n    return this.totalWeight();\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeight(TConsensus consensusAddr) external view returns (uint256) {\n    return _getConsensusWeightByConsensus(consensusAddr);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeightById(address cid) external view returns (uint256) {\n    return _getConsensusWeightByConsensus(__cid2css(cid));\n  }\n\n  function _getConsensusWeightByConsensus(TConsensus consensusAddr) internal view returns (uint256) {\n    return _consensusWeight[consensusAddr];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getGovernorWeight(address _governor) external view returns (uint256) {\n    return _governorWeight[_governor];\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeights(TConsensus[] calldata list) external view returns (uint256[] memory) {\n    return _getManyConsensusWeightsByConsensus(list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getConsensusWeightsById(address[] calldata cids) external view returns (uint256[] memory) {\n    TConsensus[] memory consensusList = __cid2cssBatch(cids);\n    return _getManyConsensusWeightsByConsensus(consensusList);\n  }\n\n  function _getManyConsensusWeightsByConsensus(TConsensus[] memory list) internal view returns (uint256[] memory res) {\n    res = new uint256[](list.length);\n    for (uint i = 0; i < res.length; ++i) {\n      res[i] = _getConsensusWeightByConsensus(list[i]);\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getGovernorWeights(address[] calldata _list) external view returns (uint256[] memory _res) {\n    _res = new uint256[](_list.length);\n    for (uint _i = 0; _i < _res.length; ) {\n      _res[_i] = _governorWeight[_list[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumConsensusWeight(TConsensus[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; ) {\n      _res += _consensusWeight[_list[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function sumGovernorWeight(address[] calldata _list) external view returns (uint256 _res) {\n    for (uint _i = 0; _i < _list.length; ) {\n      _res += _governorWeight[_list[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  function sumGovernorWeights(address[] calldata _list) external view returns (uint256 _res) {\n    return this.sumGovernorWeight(_list);\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function countTrustedOrganization() external view override returns (uint256) {\n    return _consensusList.length;\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getAllTrustedOrganizations() external view override returns (TrustedOrganization[] memory list) {\n    list = new TrustedOrganization[](_consensusList.length);\n    TConsensus consensus;\n    for (uint256 _i; _i < list.length; ) {\n      consensus = _consensusList[_i];\n      list[_i].consensusAddr = consensus;\n      list[_i].governor = _governorList[_i];\n      list[_i].__deprecatedBridgeVoter = address(0);\n      list[_i].weight = _consensusWeight[consensus];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getTrustedOrganization(TConsensus _consensusAddr) external view returns (TrustedOrganization memory res) {\n    for (uint i = 0; i < _consensusList.length; ++i) {\n      if (_consensusList[i] == _consensusAddr) {\n        res = getTrustedOrganizationAt(i);\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function getTrustedOrganizationAt(uint256 _idx) public view override returns (TrustedOrganization memory) {\n    TConsensus consensus = _consensusList[_idx];\n    return\n      TrustedOrganization(\n        consensus,\n        _governorList[_idx],\n        address(0),\n        _consensusWeight[consensus],\n        _addedBlock[consensus]\n      );\n  }\n\n  /**\n   * @inheritdoc IRoninTrustedOrganization\n   */\n  function execChangeConsensusAddressForTrustedOrg(\n    TConsensus oldAddr,\n    TConsensus newAddr\n  ) external override onlyContract(ContractType.PROFILE) {\n    (bool found, uint256 index) = _findTrustedOrgIndexByConsensus(oldAddr);\n    if (!found) revert ErrConsensusAddressIsNotAdded(oldAddr);\n\n    _consensusList[index] = newAddr;\n    _consensusWeight[newAddr] = _consensusWeight[oldAddr];\n    _addedBlock[newAddr] = block.number;\n\n    _deleteConsensusInMappings(oldAddr);\n\n    emit ConsensusAddressOfTrustedOrgChanged(getTrustedOrganizationAt(index), oldAddr);\n  }\n\n  /**\n   * @dev Adds a list of trusted organizations.\n   */\n  function _addTrustedOrganizations(TrustedOrganization[] calldata _list) internal virtual {\n    for (uint256 _i; _i < _list.length; ) {\n      _addTrustedOrganization(_list[_i]);\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit TrustedOrganizationsAdded(_list);\n  }\n\n  /**\n   * @dev Adds a trusted organization.\n   *\n   * Requirements:\n   * - The weight is larger than 0.\n   * - The consensus address is not added.\n   * - The governor address is not added.\n   * - The bridge voter address is not added.\n   *\n   */\n  function _addTrustedOrganization(TrustedOrganization memory _v) internal virtual {\n    if (_v.addedBlock != 0) revert ErrInvalidRequest();\n    _sanityCheckTrustedOrganizationData(_v);\n\n    if (_consensusWeight[_v.consensusAddr] > 0) revert ErrConsensusAddressIsAlreadyAdded(_v.consensusAddr);\n\n    if (_governorWeight[_v.governor] > 0) revert ErrGovernorAddressIsAlreadyAdded(_v.governor);\n\n    _consensusList.push(_v.consensusAddr);\n    _consensusWeight[_v.consensusAddr] = _v.weight;\n\n    _governorList.push(_v.governor);\n    _governorWeight[_v.governor] = _v.weight;\n\n    _addedBlock[_v.consensusAddr] = block.number;\n\n    _totalWeight += _v.weight;\n  }\n\n  /**\n   * @dev Updates info of an existing trusted org.\n   * Replace the governor address if they are different, set all weights to the new weight.\n   *\n   * Requirements:\n   * - The weight is larger than 0.\n   * - The consensus address is already added.\n   *\n   */\n  function _updateTrustedOrganization(TrustedOrganization memory _v) internal virtual {\n    _sanityCheckTrustedOrganizationData(_v);\n\n    uint256 _weight = _consensusWeight[_v.consensusAddr];\n    if (_weight == 0) revert ErrConsensusAddressIsNotAdded(_v.consensusAddr);\n\n    uint256 _count = _consensusList.length;\n    for (uint256 _i = 0; _i < _count; ) {\n      if (_consensusList[_i] == _v.consensusAddr) {\n        _totalWeight -= _weight;\n        _totalWeight += _v.weight;\n\n        // Replace governor address\n        if (_governorList[_i] != _v.governor) {\n          if (_governorWeight[_v.governor] != 0) revert ErrQueryForDupplicated();\n\n          delete _governorWeight[_governorList[_i]];\n          _governorList[_i] = _v.governor;\n        }\n\n        // Add new weight for both consensus and governor address\n        _consensusWeight[_v.consensusAddr] = _v.weight;\n        _governorWeight[_v.governor] = _v.weight;\n        return;\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Removes a trusted organization by consensus address.\n   *\n   * Requirements:\n   * - The consensus address is added.\n   *\n   */\n  function _removeTrustedOrganization(TConsensus addr) internal virtual {\n    uint256 weight = _consensusWeight[addr];\n    if (weight == 0) revert ErrConsensusAddressIsNotAdded(addr);\n\n    (, uint256 index) = _findTrustedOrgIndexByConsensus(addr);\n\n    _totalWeight -= weight;\n    _deleteConsensusInMappings(addr);\n\n    uint256 count = _consensusList.length;\n    _consensusList[index] = _consensusList[count - 1];\n    _consensusList.pop();\n\n    delete _governorWeight[_governorList[index]];\n    _governorList[index] = _governorList[count - 1];\n    _governorList.pop();\n  }\n\n  function _findTrustedOrgIndexByConsensus(TConsensus addr) private view returns (bool found, uint256 index) {\n    uint256 count = _consensusList.length;\n    for (uint256 i = 0; i < count; i++) {\n      if (_consensusList[i] == addr) {\n        return (true, i);\n      }\n    }\n  }\n\n  function _deleteConsensusInMappings(TConsensus addr) private {\n    delete _addedBlock[addr];\n    delete _consensusWeight[addr];\n  }\n\n  /**\n   * @dev Sets threshold and returns the old one.\n   *\n   * Emits the `ThresholdUpdated` event.\n   *\n   */\n  function _setThreshold(\n    uint256 _numerator,\n    uint256 _denominator\n  ) internal virtual returns (uint256 _previousNum, uint256 _previousDenom) {\n    if (_numerator > _denominator) revert ErrInvalidThreshold(msg.sig);\n\n    _previousNum = _num;\n    _previousDenom = _denom;\n    _num = _numerator;\n    _denom = _denominator;\n    unchecked {\n      emit ThresholdUpdated(_nonce++, _numerator, _denominator, _previousNum, _previousDenom);\n    }\n  }\n\n  /**\n   * @dev Hook that checks trusted organization's data. Reverts if the requirements are not met.\n   *\n   * Requirements:\n   * - The weight must be larger than 0.\n   * - The consensus address, governor address, and bridge voter address are different.\n   */\n  function _sanityCheckTrustedOrganizationData(TrustedOrganization memory _v) private pure {\n    if (_v.weight == 0) revert ErrInvalidVoteWeight(msg.sig);\n\n    address[] memory _addresses = new address[](3);\n    _addresses[0] = TConsensus.unwrap(_v.consensusAddr);\n    _addresses[1] = _v.governor;\n    _addresses[2] = _v.__deprecatedBridgeVoter;\n\n    if (AddressArrayUtils.hasDuplicate(_addresses)) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  function __cid2css(address cid) internal view returns (TConsensus) {\n    return (IProfile(getContract(ContractType.PROFILE)).getId2Profile(cid)).consensus;\n  }\n\n  function __cid2cssBatch(address[] memory cids) internal view returns (TConsensus[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyId2Consensus(cids);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUPickValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUPickValidatorSet is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of picking validator set\n  function precompilePickValidatorSetAddress() public view virtual returns (address) {\n    return address(0x68);\n  }\n\n  /**\n   * @dev Sorts and arranges to return a new validator set.\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcPickValidatorSet(\n    address[] memory _candidates,\n    uint256[] memory _weights,\n    uint256[] memory _trustedWeights,\n    uint256 _maxValidatorNumber,\n    uint256 _maxPrioritizedValidatorNumber\n  ) internal view virtual returns (address[] memory _result, uint256 _newValidatorCount) {\n    address _smc = precompilePickValidatorSetAddress();\n    bytes memory _payload = abi.encodeWithSignature(\n      \"pickValidatorSet(address[],uint256[],uint256[],uint256,uint256)\",\n      _candidates,\n      _weights,\n      _trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    bool _success = true;\n\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n\n    _newValidatorCount = _result.length;\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUSortValidators.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUSortValidators is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of sorting validators\n  function precompileSortValidatorsAddress() public view virtual returns (address) {\n    return address(0x66);\n  }\n\n  /**\n   * @dev Sorts candidates descending by their weights by calling precompile contract.\n   *\n   * Note: This function is marked as virtual for being wrapping in mock contract for testing purpose.\n   */\n  function _pcSortCandidates(\n    address[] memory _candidates,\n    uint256[] memory _weights\n  ) internal view virtual returns (address[] memory _result) {\n    address _smc = precompileSortValidatorsAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\"sortValidators(address[],uint256[])\", _candidates, _weights);\n    uint256 _payloadLength = _payload.length;\n    uint256 _resultLength = 0x20 * _candidates.length + 0x40;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _result, _resultLength)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n\n      _result := add(_result, 0x20)\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateDoubleSign is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateDoubleSignAddress() public view virtual returns (address) {\n    return address(0x67);\n  }\n\n  /**\n   * @dev Validates the two submitted block header if they are produced by the same address\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateEvidence(\n    address _consensusAddr,\n    bytes calldata _header1,\n    bytes calldata _header2\n  ) internal view virtual returns (bool _validEvidence) {\n    address _smc = precompileValidateDoubleSignAddress();\n    bool _success = true;\n\n    bytes memory _payload = abi.encodeWithSignature(\n      \"validatingDoubleSignProof(address,bytes,bytes)\",\n      _consensusAddr,\n      _header1,\n      _header2\n    );\n    uint _payloadLength = _payload.length;\n    uint[1] memory _output;\n\n    assembly {\n      let _payloadStart := add(_payload, 0x20)\n      if iszero(staticcall(gas(), _smc, _payloadStart, _payloadLength, _output, 0x20)) {\n        _success := 0\n      }\n\n      if iszero(returndatasize()) {\n        _success := 0\n      }\n    }\n\n    if (!_success) revert ErrCallPrecompiled();\n    return (_output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUValidateFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUValidateFastFinality is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileValidateFastFinalityAddress() public view virtual returns (address) {\n    return address(0x69);\n  }\n\n  /**\n   * @dev Validates the proof of malicious voting on fast finality\n   *\n   * Note: The recover process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcValidateFastFinalityEvidence(\n    bytes memory voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] memory targetBlockHash,\n    bytes[][2] memory listOfPublicKey,\n    bytes[2] memory aggregatedSignature\n  ) internal view virtual returns (bool validEvidence) {\n    address smc = precompileValidateFastFinalityAddress();\n    bool success = true;\n\n    bytes memory payload = abi.encodeWithSignature(\n      \"validateFinalityVoteProof(bytes,uint256,bytes32[2],bytes[][2],bytes[2])\",\n      voterPublicKey,\n      targetBlockNumber,\n      targetBlockHash,\n      listOfPublicKey,\n      aggregatedSignature\n    );\n    uint payloadLength = payload.length;\n    uint[1] memory output;\n\n    assembly {\n      let payloadStart := add(payload, 0x20)\n      if iszero(staticcall(gas(), smc, payloadStart, payloadLength, output, 0x20)) {\n        success := 0\n      }\n\n      if iszero(returndatasize()) {\n        success := 0\n      }\n    }\n\n    if (!success) revert ErrCallPrecompiled();\n    return (output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PCUVerifyBLSPublicKey.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PCUVerifyBLSPublicKey is PrecompiledUsage {\n  /// @dev Gets the address of the precompile of validating double sign evidence\n  function precompileVerifyBLSPublicKeyAddress() public view virtual returns (address) {\n    return address(0x6a);\n  }\n\n  /**\n   * @dev Validates the proof of possession of BLS public key\n   *\n   * Note: The verify process is done by pre-compiled contract. This function is marked as\n   * virtual for implementing mocking contract for testing purpose.\n   */\n  function _pcVerifyBLSPublicKey(\n    bytes calldata publicKey,\n    bytes calldata proofOfPossession\n  ) internal view virtual returns (bool validPublicKey) {\n    address smc = precompileVerifyBLSPublicKeyAddress();\n    bool success = true;\n\n    bytes memory payload = abi.encodeWithSignature(\n      \"validateProofOfPossession(bytes,bytes)\",\n      publicKey,\n      proofOfPossession\n    );\n    uint payloadLength = payload.length;\n    uint[1] memory output;\n\n    assembly {\n      let payloadStart := add(payload, 0x20)\n      if iszero(staticcall(gas(), smc, payloadStart, payloadLength, output, 0x20)) {\n        success := 0\n      }\n\n      if iszero(returndatasize()) {\n        success := 0\n      }\n    }\n\n    if (!success) revert ErrCallPrecompiled();\n    return (output[0] != 0);\n  }\n}\n"
    },
    "contracts/precompile-usages/PrecompiledUsage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./PrecompiledUsage.sol\";\n\nabstract contract PrecompiledUsage {\n  /// @dev Error of call to precompile fails.\n  error ErrCallPrecompiled();\n}\n"
    },
    "contracts/ronin/Maintenance.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../interfaces/IMaintenance.sol\";\nimport \"../interfaces/IProfile.sol\";\nimport \"../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../extensions/collections/HasContracts.sol\";\nimport \"../libraries/Math.sol\";\nimport { HasValidatorDeprecated } from \"../utils/DeprecatedSlots.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../utils/CommonErrors.sol\";\n\ncontract Maintenance is IMaintenance, HasContracts, HasValidatorDeprecated, Initializable {\n  using Math for uint256;\n\n  /// @dev Mapping from candidate id => maintenance schedule.\n  mapping(address => Schedule) internal _schedule;\n\n  /// @dev The min duration to maintenance in blocks.\n  uint256 internal _minMaintenanceDurationInBlock;\n  /// @dev The max duration to maintenance in blocks.\n  uint256 internal _maxMaintenanceDurationInBlock;\n  /// @dev The offset to the min block number that the schedule can start.\n  uint256 internal _minOffsetToStartSchedule;\n  /// @dev The offset to the max block number that the schedule can start.\n  uint256 internal _maxOffsetToStartSchedule;\n  /// @dev The max number of scheduled maintenances.\n  uint256 internal _maxSchedule;\n  /// @dev The cooldown time to request new schedule.\n  uint256 internal _cooldownSecsToMaintain;\n\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address validatorContract,\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedule_,\n    uint256 cooldownSecsToMaintain_\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n    _setMaintenanceConfig(\n      minMaintenanceDurationInBlock_,\n      maxMaintenanceDurationInBlock_,\n      minOffsetToStartSchedule_,\n      maxOffsetToStartSchedule_,\n      maxSchedule_,\n      cooldownSecsToMaintain_\n    );\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    delete ______deprecatedValidator;\n  }\n\n  function initializeV3(address profileContract_) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, profileContract_);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function minMaintenanceDurationInBlock() external view returns (uint256) {\n    return _minMaintenanceDurationInBlock;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function maxMaintenanceDurationInBlock() external view returns (uint256) {\n    return _maxMaintenanceDurationInBlock;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function minOffsetToStartSchedule() external view returns (uint256) {\n    return _minOffsetToStartSchedule;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function maxOffsetToStartSchedule() external view returns (uint256) {\n    return _maxOffsetToStartSchedule;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function maxSchedule() external view returns (uint256) {\n    return _maxSchedule;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function cooldownSecsToMaintain() external view returns (uint256) {\n    return _cooldownSecsToMaintain;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedule_,\n    uint256 cooldownSecsToMaintain_\n  ) external onlyAdmin {\n    _setMaintenanceConfig(\n      minMaintenanceDurationInBlock_,\n      maxMaintenanceDurationInBlock_,\n      minOffsetToStartSchedule_,\n      maxOffsetToStartSchedule_,\n      maxSchedule_,\n      cooldownSecsToMaintain_\n    );\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function schedule(TConsensus consensusAddr, uint256 startedAtBlock, uint256 endedAtBlock) external override {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    address candidateId = __css2cid(consensusAddr);\n\n    if (!validatorContract.isBlockProducer(consensusAddr)) revert ErrUnauthorized(msg.sig, RoleAccess.BLOCK_PRODUCER);\n    if (!validatorContract.isCandidateAdmin(consensusAddr, msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n    if (_checkScheduledById(candidateId)) revert ErrAlreadyScheduled();\n    if (!_checkCooldownEndedById(candidateId)) revert ErrCooldownTimeNotYetEnded();\n    if (totalSchedule() >= _maxSchedule) revert ErrTotalOfSchedulesExceeded();\n    if (!startedAtBlock.inRange(block.number + _minOffsetToStartSchedule, block.number + _maxOffsetToStartSchedule)) {\n      revert ErrStartBlockOutOfRange();\n    }\n    if (startedAtBlock >= endedAtBlock) revert ErrStartBlockOutOfRange();\n\n    uint256 maintenanceElapsed = endedAtBlock - startedAtBlock + 1;\n\n    if (!maintenanceElapsed.inRange(_minMaintenanceDurationInBlock, _maxMaintenanceDurationInBlock)) {\n      revert ErrInvalidMaintenanceDuration();\n    }\n    if (!validatorContract.epochEndingAt(startedAtBlock - 1)) revert ErrStartBlockOutOfRange();\n    if (!validatorContract.epochEndingAt(endedAtBlock)) revert ErrEndBlockOutOfRange();\n\n    Schedule storage _sSchedule = _schedule[candidateId];\n    _sSchedule.from = startedAtBlock;\n    _sSchedule.to = endedAtBlock;\n    _sSchedule.lastUpdatedBlock = block.number;\n    _sSchedule.requestTimestamp = block.timestamp;\n    emit MaintenanceScheduled(candidateId, _sSchedule);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function cancelSchedule(TConsensus consensusAddr) external override {\n    if (!IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isCandidateAdmin(consensusAddr, msg.sender)) {\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n    }\n\n    address candidateId = __css2cid(consensusAddr);\n\n    if (!_checkScheduledById(candidateId)) revert ErrUnexistedSchedule();\n    if (_checkMaintainedById(candidateId, block.number)) revert ErrAlreadyOnMaintenance();\n\n    Schedule storage _sSchedule = _schedule[candidateId];\n    delete _sSchedule.from;\n    delete _sSchedule.to;\n    _sSchedule.lastUpdatedBlock = block.number;\n    emit MaintenanceScheduleCancelled(candidateId);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function getSchedule(TConsensus consensusAddr) external view override returns (Schedule memory) {\n    return _schedule[__css2cid(consensusAddr)];\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkManyMaintained(\n    TConsensus[] calldata addrList,\n    uint256 atBlock\n  ) external view override returns (bool[] memory) {\n    address[] memory idList = __css2cidBatch(addrList);\n    return _checkManyMaintainedById(idList, atBlock);\n  }\n\n  function checkManyMaintainedById(\n    address[] calldata idList,\n    uint256 atBlock\n  ) external view override returns (bool[] memory) {\n    return _checkManyMaintainedById(idList, atBlock);\n  }\n\n  function _checkManyMaintainedById(\n    address[] memory idList,\n    uint256 atBlock\n  ) internal view returns (bool[] memory resList) {\n    resList = new bool[](idList.length);\n    for (uint i = 0; i < idList.length; ) {\n      resList[i] = _checkMaintainedById(idList[i], atBlock);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkManyMaintainedInBlockRange(\n    TConsensus[] calldata addrList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view override returns (bool[] memory) {\n    address[] memory idList = __css2cidBatch(addrList);\n    return _checkManyMaintainedInBlockRangeById(idList, fromBlock, toBlock);\n  }\n\n  function checkManyMaintainedInBlockRangeById(\n    address[] calldata idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) external view override returns (bool[] memory) {\n    return _checkManyMaintainedInBlockRangeById(idList, fromBlock, toBlock);\n  }\n\n  function _checkManyMaintainedInBlockRangeById(\n    address[] memory idList,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) internal view returns (bool[] memory resList) {\n    resList = new bool[](idList.length);\n    for (uint i = 0; i < idList.length; ) {\n      resList[i] = _maintainingInBlockRange(idList[i], fromBlock, toBlock);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function totalSchedule() public view override returns (uint256 count) {\n    address[] memory validatorIds = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).getValidatorIds();\n    unchecked {\n      for (uint i = 0; i < validatorIds.length; i++) {\n        if (_checkScheduledById(validatorIds[i])) {\n          count++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkMaintained(TConsensus consensusAddr, uint256 atBlock) external view override returns (bool) {\n    return _checkMaintainedById(__css2cid(consensusAddr), atBlock);\n  }\n\n  function checkMaintainedById(address candidateId, uint256 atBlock) external view override returns (bool) {\n    return _checkMaintainedById(candidateId, atBlock);\n  }\n\n  function _checkMaintainedById(address candidateId, uint256 atBlock) internal view returns (bool) {\n    Schedule storage _s = _schedule[candidateId];\n    return _s.from <= atBlock && atBlock <= _s.to;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkMaintainedInBlockRange(\n    TConsensus consensusAddr,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) public view override returns (bool) {\n    return _maintainingInBlockRange(__css2cid(consensusAddr), fromBlock, toBlock);\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkScheduled(TConsensus consensusAddr) external view override returns (bool) {\n    return _checkScheduledById(__css2cid(consensusAddr));\n  }\n\n  function _checkScheduledById(address candidateId) internal view returns (bool) {\n    return block.number <= _schedule[candidateId].to;\n  }\n\n  /**\n   * @inheritdoc IMaintenance\n   */\n  function checkCooldownEnded(TConsensus consensusAddr) external view override returns (bool) {\n    return _checkCooldownEndedById(__css2cid(consensusAddr));\n  }\n\n  function _checkCooldownEndedById(address candidateId) internal view returns (bool) {\n    return block.timestamp > _schedule[candidateId].requestTimestamp + _cooldownSecsToMaintain;\n  }\n\n  /**\n   * @dev Sets the min block period and max block period to maintenance.\n   *\n   * Requirements:\n   * - The max period is larger than the min period.\n   *\n   * Emits the event `MaintenanceConfigUpdated`.\n   *\n   */\n  function _setMaintenanceConfig(\n    uint256 minMaintenanceDurationInBlock_,\n    uint256 maxMaintenanceDurationInBlock_,\n    uint256 minOffsetToStartSchedule_,\n    uint256 maxOffsetToStartSchedule_,\n    uint256 maxSchedule_,\n    uint256 cooldownSecsToMaintain_\n  ) internal {\n    if (minMaintenanceDurationInBlock_ >= maxMaintenanceDurationInBlock_) revert ErrInvalidMaintenanceDurationConfig();\n    if (minOffsetToStartSchedule_ >= maxOffsetToStartSchedule_) revert ErrInvalidOffsetToStartScheduleConfigs();\n\n    _minMaintenanceDurationInBlock = minMaintenanceDurationInBlock_;\n    _maxMaintenanceDurationInBlock = maxMaintenanceDurationInBlock_;\n    _minOffsetToStartSchedule = minOffsetToStartSchedule_;\n    _maxOffsetToStartSchedule = maxOffsetToStartSchedule_;\n    _maxSchedule = maxSchedule_;\n    _cooldownSecsToMaintain = cooldownSecsToMaintain_;\n    emit MaintenanceConfigUpdated(\n      minMaintenanceDurationInBlock_,\n      maxMaintenanceDurationInBlock_,\n      minOffsetToStartSchedule_,\n      maxOffsetToStartSchedule_,\n      maxSchedule_,\n      cooldownSecsToMaintain_\n    );\n  }\n\n  /**\n   * @dev Check if the validator was maintaining in the current period.\n   *\n   * Note: This method should be called at the end of the period.\n   */\n  function _maintainingInBlockRange(\n    address candidateId,\n    uint256 fromBlock,\n    uint256 toBlock\n  ) private view returns (bool) {\n    Schedule storage s = _schedule[candidateId];\n    return Math.twoRangeOverlap(fromBlock, toBlock, s.from, s.to);\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile_Mainnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./Profile.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile_Mainnet is Profile {\n  function __migrationRenouncedCandidates() internal override onlyInitializing {\n    if (block.chainid != 2020) return;\n\n    address[4] memory lConsensus = __consensuses();\n    address[4] memory lAdmin = __admins();\n    address[4] memory lTreasury = __treasuries();\n\n    for (uint i; i < lConsensus.length; ++i) {\n      __migrate(lConsensus[i], lAdmin[i], lTreasury[i]);\n    }\n  }\n\n  function __admins() private pure returns (address[4] memory list) {\n    return [\n      0xdb3b1F69259f88Ce9d58f3738e15e3CC1B5A8563,\n      0x335fE9EF827a9F27CBAb819b31e5eE182c2081d7,\n      0xbCcB3FDa2B9e3Ab5b824AA9D5c1C4A62A98Da937,\n      0x9bc1946f1Aa6DA4667a6Ee966e66b9ec60637E10\n    ];\n  }\n\n  function __consensuses() private pure returns (address[4] memory list) {\n    return [\n      0x07d28F88D677C4056EA6722aa35d92903b2a63da,\n      0x262B9fcfe8CFA900aF4D1f5c20396E969B9655DD,\n      0x20238eB5643d4D7b7Ab3C30f3bf7B8E2B85cA1e7,\n      0x03A7B98C226225e330d11D1B9177891391Fa4f80\n    ];\n  }\n\n  function __treasuries() private pure returns (address[4] memory list) {\n    return [\n      0xdb3b1F69259f88Ce9d58f3738e15e3CC1B5A8563,\n      0x335fE9EF827a9F27CBAb819b31e5eE182c2081d7,\n      0xbCcB3FDa2B9e3Ab5b824AA9D5c1C4A62A98Da937,\n      0x9bc1946f1Aa6DA4667a6Ee966e66b9ec60637E10\n    ];\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile_Testnet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"./Profile.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile_Testnet is Profile {\n  function migrateRenouncedCandidate() external onlyAdmin {\n    __defaultMigrate();\n  }\n\n  function manualMigrate(address id, address candidateAdmin, address treasury) external onlyAdmin {\n    __migrate(id, candidateAdmin, treasury);\n  }\n\n  function __migrationRenouncedCandidates() internal override onlyInitializing {\n    __defaultMigrate();\n  }\n\n  function __defaultMigrate() private {\n    if (block.chainid != 2021) return;\n\n    address[76] memory lConsensus = __consensuses();\n    address[76] memory lAdmin = __admins();\n    address[76] memory lTreasury = __treasuries();\n\n    for (uint i; i < lConsensus.length; ++i) {\n      __migrate(lConsensus[i], lAdmin[i], lTreasury[i]);\n    }\n  }\n\n  function __admins() private pure returns (address[76] memory list) {\n    return [\n      0xcF0E23AED16D5d971910e748ACd48849E4b7239C, // outside validator,\n      0x32f66D0F9F19db7B0EF1E9F13160884Da65467E6, // outside validator,\n      0xD682DC6D64710D6191512133dE957e146e9AA58f,\n      0xEFeaFf1d9f1E4EDB00c6084aE4016143B29Ed924,\n      0xC2caE7311FC0fe400A838d2dDe06A89E1d3e9Da7,\n      0xf90a912Fdb7Fd37572cD83325392d729e60Ef682,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x8dA9d88F90141a03292d5e554691B1F6e7c6212c,\n      0xA87F9A2F0C7082FA2f1E3de1090D36047C7cD017,\n      0x6693dc258BDAAc5052ab678BA5de2440CA1cdAbe,\n      0x0B67dF5847aF7476B2EB46da328638E0fB2C6B29,\n      0xe91d1DCd0232BDa301379dE27bd0edE47Db3F750,\n      0xDc3de716C4430d598AC504c4685d69D0DcE1412F,\n      0x795CF28E5b71f1A50cC9E01077891C18D6587e53,\n      0xa3B3c71371331fD1901e316B67df2d16bF5535a0,\n      0x32Be208dE8A1595cC0ccf8E984CAB8759Ea1e5b2,\n      0x8136c74e94b08300d71Fa6C22087b821F73568c5,\n      0xda6c7342E90B77c5C77A8F7292765360099e30Ed,\n      0x95fC818CD7709fb6aD8920d0d14925010504876F,\n      0xe8E66b241414a40a3Db539eC7d864cD61938f817,\n      0xfD575770A68D5Af983b2A374981f604DdAD9D684,\n      0x9A54EDCb1D9a44e9f4235ea05c75B45b26679680,\n      0x6108570A29f500D6950fEbffC99ECB66a264A048,\n      0xdA071F710b0f82443866616E8a96069012A73ccf,\n      0x8A4ac64764238C71Ddf82F870BE6526e297Dc4Cd,\n      0x33f1727CaA54AE24CAdB2949881C3725eB61a100,\n      0x34DB532F09Ee1285DFEf26eD696c4eA25dcFce72,\n      0x302d51189FD89D7e72bcb26a65D16941d043F089,\n      0xFeb247F76E6F6C1Ec3455d04e6E3B694a577D57C,\n      0x05955d9e99f57E5574A1a9b73361DD14aEc8D641,\n      0xcf9F44dDB18a5538Efe2a2A28eF20300333f5a71,\n      0x779dCE1ddc28941Ec85bf2aE0dAC9F0f12836281,\n      0x0Bb270e5268a9E9a0742DdB027Fab7405Af56Fa7,\n      0x5b92Ea265597a7cf20C8dA56E6beb8485c1BA993,\n      0x0E3341Ae4Ed9dA65Fc30a7Fa6357e8B5Ac40b0A3,\n      0xf6fd5FcA4Bd769BA495B29B98dba5F2eCF4CEED3,\n      0x8d0a639BDD3b81dF264c4dB46476658858231510,\n      0xBB046932fEFCDD3Be4368444a1014F25DfEE83f2,\n      0x54e09bF04810f387347dA6D9687D6a37EC2aadC7,\n      0xDE5e1554e2bF5d0E54BafC74C932b8F2aD4e273F,\n      0xc68d0255e1b9C549C43c7181BD29684DC477edfc,\n      0x37920733DB9A5b45fC9CD5e3C80825bEfFC1a014,\n      0x7e9107480Bf92dd56c97118E20CdB3c1Ae9dD866,\n      0xC4F83A7b369070E32CEd4Bd6Fd647D19AEf828AC,\n      0x412D4d69122839FcCAd0180e9358d157C3876f3C,\n      0x355503B8E64205FDE9dBBAD269110991cf736a50,\n      0x306f23c32fdfC07850Bf242E8Ff59C5E79BFf812,\n      0x467c5425042C9D9f025265b72C93D73E0F2978C5,\n      0xEE992B0F5E9746fdb8e584Efa01AF79f6B1C0940,\n      0xBD6342c0009f55131b7a51f627CE8Cc87879DD66,\n      0x57018e929Eb6fe50355bF1BF9D1d39cA466b7Fa0,\n      0xAd4e3D2F85b4C095742B500751CEE5c4B8f65A5b,\n      0x89A6A074dB8BcD3Fd60626107eA2aE576693F7c5,\n      0xCB742186fA056444766fA7cc52a0479E8F6DEDEA,\n      0x60C8117901Ab35738fcFd7157D393207eFCe8055,\n      0xAD70AD152E27E0923C4f11C63490FCFD904A4C36,\n      0xd8b47b81648d9e81e50b8cA21EA81F2E1B6929BB,\n      0xeCB1374172970a613A1970370B3ddeAD8F844733,\n      0x0472dCa02318B532Fcb0B056661EE7fD2Adc8a20,\n      0xdd00ACc07F3F7AFa90B5a22cFd56c0808b6444dd,\n      0x4d3302c69fac489E2F7373bCB2f101d3B378c4Ce,\n      0xe7685E437F34De2D36eA2e9AB13E5Ab871711A2C,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x3F9Df0717099BAaA95A14B3CAA285DAdDAFb0609,\n      0x23Dffc4a93c374A91Fbc1c33075af012b68663F7,\n      0x79eC4d83D40c1Bd1419D8f561BE851FDa1EA32a6,\n      0x2D3f28780bFb7Ed6FB5547c309E1a6837e5bD12B,\n      0xa164e8B5F90ce42B0F531E3882cdE3F698e1121f,\n      0x4a4bc674A97737376cFE990aE2fE0d2B6E738393,\n      0xF61806B65278fFDbF8b04f832C59b65076798Fb6,\n      0x836eeEdd931575CCE4285c74C15DBdA9Edc3Dc4F,\n      0xbd95B0581585E4151793b183ee75d509fDE528B6,\n      0xA75B1Ce2f8C447caB6c13F313dfd806287aA47e2,\n      0x4D546475321b4cA2a91B101f26750092C05350cF,\n      0xFC2d29Da710F45168DE11e5C051CaA558088D52a,\n      0x1C70B8160E92D56E550caf02e1f2e5EC0Fdb551A\n    ];\n  }\n\n  function __consensuses() private pure returns (address[76] memory list) {\n    return [\n      0x9687e8C41fa369aD08FD278a43114C4207856a61, // outside validator\n      0x32F66d0F9F19Db7b0EF1E9f13160884DA65467e7, // outside validator\n      0xD682dc6D64710D6191512133De957e146e9Aa58e,\n      0xEFeaFf1d9f1e4eDB00C6084ae4016143B29eD925,\n      0x57b572A9de68Bd29074e1C51c790Fc45C592ba39,\n      0xC0C2A56F9606bA109d37A0d18AF8E5bAA1e1C0aD,\n      0xaFB9554299491a34d303F2C5A91bebb162f6b2C1,\n      0x533f61B360e81f58919faB5C653724F71faf12ab,\n      0xa87F9A2F0C7082FA2f1E3De1090d36047c7cD018,\n      0x6693Dc258bDAaC5052aB678Ba5de2440ca1cDAb2,\n      0x96f78323481fc9abdb8Cc4D8aa50C1500AC93b92,\n      0xe91D1DcD0232BDa301379de27BD0edE47Db3f751,\n      0x981676e5E5164524e70f79AC45b52099EbDA8781,\n      0x795cf28e5B71f1A50cc9E01077891C18D6587E54,\n      0xa3b3C71371331fD1901e316B67DF2d16Bf5535A1,\n      0x32be208de8A1595cC0CcF8E984Cab8759Ea1e5b9,\n      0x2dc14d542B5478f206B296AcbCBfBCCEE6E8D248,\n      0xDA6C7342E90B77c5c77a8F7292765360099E30EE,\n      0x9D7EA2223e89A55a4ef69Ca993eae6FDE6E63371,\n      0xe8e66b241414a40a3db539EC7d864cD61938f818,\n      0x8fFF45d4a6A27F8256dF19D0DaDF7787CfbE56AA,\n      0x9a54EdCb1D9a44e9F4235EA05C75B45B26679681,\n      0x6108570A29F500D6950FEbFFc99eCB66a264a049,\n      0xDA071f710B0f82443866616E8a96069012A73cCE,\n      0x5f7f2AE316ec5C092d201744fe8337353ADB2BB3,\n      0x771DEc03db66a566a1DfE3fd635B3f8D404b9291,\n      0x71f9154ADc0bef39Bbe8dB1D060E6F239D2E10AE,\n      0x95908d03bA55c2a44688330b59E746Fdb2f17E3E,\n      0x3DB3abc65F203788836C8D50F6923C56f3f0FF7c,\n      0x05955D9e99f57E5574a1A9B73361Dd14aEC8D642,\n      0x283b4Baa1d0415603C81edc1C68FadD3C790837C,\n      0x2A5EB3f9CD4D6Ef49dc2a30041e4421af3303929,\n      0x3B9F2587d55E96276B09b258ac909D809961F6C2,\n      0x2576e6BC92A493F4DA6335C5E69BC0c272381C3A,\n      0x0E3341Ae4Ed9dA65Fc30a7Fa6357e8B5Ac40b0A3,\n      0xf6fd5FcA4Bd769BA495B29B98dba5F2eCF4CEED3,\n      0xd9299FA321407a5d10c73d71C57Ca687A2A38Af6,\n      0x877eFEfFE7A23E42C39e2C99b977e4AA4BEC7517,\n      0x071b510C415d3f84C6F4C6291C49887cC56cac41,\n      0xDE5e1554e2bF5d0e54bAFC74c932b8f2Ad4E2730,\n      0xc68d0255E1b9C549C43C7181bd29684DC477eDf0,\n      0xC3fB7b95b874bfcBD1E722A2061f3adf217121d3,\n      0x36Fd0d4A075507a4E742631aA37DAD46a1F4c0da,\n      0x661549d7717C20ffa62AD359B7667Bbf5c82053B,\n      0x412d4d69122839fcCAd0180e9358D157C3876F3D,\n      0x355503B8E64205FDE9dBbAd269110991CF736a51,\n      0x12Cf444bf83Ed5B610d0089927EcD3baBC81Ff88,\n      0x467C5425042c9d9f025265b72c93D73e0f2978C6,\n      0xB6bc5bc0410773A3F86B1537ce7495C52e38f88B,\n      0xBd6342C0009f55131b7A51F627ce8Cc87879dD67,\n      0x35C78DefBd03E96b4E3eE6a73e9CD4C49d2b885a,\n      0xAD4e3d2f85b4C095742B500751CeE5C4b8F65A5C,\n      0x42c535deCcc071D9039b177Cb3AbF30411531b05,\n      0xb212F24D850a0Ed90F2889dee31870E7FF3fED6c,\n      0x60C8117901AB35738FcfD7157D393207Efce8056,\n      0x30b0215a442Ea3D3088Acd83cD5Fe2aA2bcd775A,\n      0xD21BeCe2D8206A3fFdBAeDb827f4D4bD0FF79e3d,\n      0x4EfA5C5Bbe7a257743335F200E86cD44eEa4dcD9,\n      0x0472dcA02318B532fcB0B056661ee7Fd2aDc8A21,\n      0xDD00ACc07f3f7Afa90B5A22CFd56c0808b6444Df,\n      0x4d3302c69fAc489E2f7373bCB2f101d3b378C4cF,\n      0x8c29604e1caE4af683c4fBdAD951F3F855890EA0,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0xF48C06c56D78F5106b8c5Fa234fCeB1d1c50096B,\n      0x626ECe2ad62F59700D2734A523FC6177005aC8b0,\n      0xc6C15480855add4eeBE365c89a9bb6f278E18254,\n      0xF6071F7905D4e4B6eBd27b819aAF8923d542FDDF,\n      0x8872fe6335267aDB4C40b9f8667095667B55dCD9,\n      0x4a4bc674A97737376cFE990aE2fE0d2B6E738393,\n      0x27550f4B37f0309C56ea67578Eb924B4c19eEEB7,\n      0x181A053fd961DC1377B84BE4E551ce277053e4C0,\n      0xf44C500a8515a5ACc900C921bC888b5b62DA6556,\n      0xF20293d569f0Ee7ECcdEF266D86EE382F8932866,\n      0xb1D4782962A407343Aa3765a599637932d241305,\n      0x7F53d703836abCaF1ca3D5607d80dd7d96e50d02,\n      0x78fD38faa30ea66702cc39383D2E84f9a4A56fA6\n    ];\n  }\n\n  function __treasuries() private pure returns (address[76] memory list) {\n    return [\n      0xcF0E23AED16D5d971910e748ACd48849E4b7239C, // outside validator\n      0x32f66D0F9F19db7B0EF1E9F13160884Da65467E6, // outside validator\n      0xD682DC6D64710D6191512133dE957e146e9AA58f,\n      0xEFeaFf1d9f1E4EDB00c6084aE4016143B29Ed924,\n      0xC2caE7311FC0fe400A838d2dDe06A89E1d3e9Da7,\n      0xf90a912Fdb7Fd37572cD83325392d729e60Ef682,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x8dA9d88F90141a03292d5e554691B1F6e7c6212c,\n      0xA87F9A2F0C7082FA2f1E3de1090D36047C7cD017,\n      0x6693dc258BDAAc5052ab678BA5de2440CA1cdAbe,\n      0x0B67dF5847aF7476B2EB46da328638E0fB2C6B29,\n      0xe91d1DCd0232BDa301379dE27bd0edE47Db3F750,\n      0xDc3de716C4430d598AC504c4685d69D0DcE1412F,\n      0x795CF28E5b71f1A50cC9E01077891C18D6587e53,\n      0xa3B3c71371331fD1901e316B67df2d16bF5535a0,\n      0x32Be208dE8A1595cC0ccf8E984CAB8759Ea1e5b2,\n      0x8136c74e94b08300d71Fa6C22087b821F73568c5,\n      0xda6c7342E90B77c5C77A8F7292765360099e30Ed,\n      0x95fC818CD7709fb6aD8920d0d14925010504876F,\n      0xe8E66b241414a40a3Db539eC7d864cD61938f817,\n      0xfD575770A68D5Af983b2A374981f604DdAD9D684,\n      0x9A54EDCb1D9a44e9f4235ea05c75B45b26679680,\n      0x6108570A29f500D6950fEbffC99ECB66a264A048,\n      0xdA071F710b0f82443866616E8a96069012A73ccf,\n      0x8A4ac64764238C71Ddf82F870BE6526e297Dc4Cd,\n      0x33f1727CaA54AE24CAdB2949881C3725eB61a100,\n      0x34DB532F09Ee1285DFEf26eD696c4eA25dcFce72,\n      0x302d51189FD89D7e72bcb26a65D16941d043F089,\n      0xFeb247F76E6F6C1Ec3455d04e6E3B694a577D57C,\n      0x05955d9e99f57E5574A1a9b73361DD14aEc8D641,\n      0xcf9F44dDB18a5538Efe2a2A28eF20300333f5a71,\n      0x779dCE1ddc28941Ec85bf2aE0dAC9F0f12836281,\n      0x0Bb270e5268a9E9a0742DdB027Fab7405Af56Fa7,\n      0x5b92Ea265597a7cf20C8dA56E6beb8485c1BA993,\n      0x0E3341Ae4Ed9dA65Fc30a7Fa6357e8B5Ac40b0A3,\n      0xf6fd5FcA4Bd769BA495B29B98dba5F2eCF4CEED3,\n      0x8d0a639BDD3b81dF264c4dB46476658858231510,\n      0xBB046932fEFCDD3Be4368444a1014F25DfEE83f2,\n      0x54e09bF04810f387347dA6D9687D6a37EC2aadC7,\n      0xDE5e1554e2bF5d0E54BafC74C932b8F2aD4e273F,\n      0xc68d0255e1b9C549C43c7181BD29684DC477edfc,\n      0x37920733DB9A5b45fC9CD5e3C80825bEfFC1a014,\n      0x7e9107480Bf92dd56c97118E20CdB3c1Ae9dD866,\n      0xC4F83A7b369070E32CEd4Bd6Fd647D19AEf828AC,\n      0x412D4d69122839FcCAd0180e9358d157C3876f3C,\n      0x355503B8E64205FDE9dBBAD269110991cf736a50,\n      0x306f23c32fdfC07850Bf242E8Ff59C5E79BFf812,\n      0x467c5425042C9D9f025265b72C93D73E0F2978C5,\n      0xEE992B0F5E9746fdb8e584Efa01AF79f6B1C0940,\n      0xBD6342c0009f55131b7a51f627CE8Cc87879DD66,\n      0x57018e929Eb6fe50355bF1BF9D1d39cA466b7Fa0,\n      0xAd4e3D2F85b4C095742B500751CEE5c4B8f65A5b,\n      0x89A6A074dB8BcD3Fd60626107eA2aE576693F7c5,\n      0xCB742186fA056444766fA7cc52a0479E8F6DEDEA,\n      0x60C8117901Ab35738fcFd7157D393207eFCe8055,\n      0xAD70AD152E27E0923C4f11C63490FCFD904A4C36,\n      0xd8b47b81648d9e81e50b8cA21EA81F2E1B6929BB,\n      0xeCB1374172970a613A1970370B3ddeAD8F844733,\n      0x0472dCa02318B532Fcb0B056661EE7fD2Adc8a20,\n      0xdd00ACc07F3F7AFa90B5a22cFd56c0808b6444dd,\n      0x4d3302c69fac489E2F7373bCB2f101d3B378c4Ce,\n      0xe7685E437F34De2D36eA2e9AB13E5Ab871711A2C,\n      0xAfB9554299491a34d303f2C5A91bebB162f6B2Cf,\n      0x3F9Df0717099BAaA95A14B3CAA285DAdDAFb0609,\n      0x23Dffc4a93c374A91Fbc1c33075af012b68663F7,\n      0x79eC4d83D40c1Bd1419D8f561BE851FDa1EA32a6,\n      0x2D3f28780bFb7Ed6FB5547c309E1a6837e5bD12B,\n      0xa164e8B5F90ce42B0F531E3882cdE3F698e1121f,\n      0x4a4bc674A97737376cFE990aE2fE0d2B6E738393,\n      0xF61806B65278fFDbF8b04f832C59b65076798Fb6,\n      0x836eeEdd931575CCE4285c74C15DBdA9Edc3Dc4F,\n      0xbd95B0581585E4151793b183ee75d509fDE528B6,\n      0xA75B1Ce2f8C447caB6c13F313dfd806287aA47e2,\n      0x4D546475321b4cA2a91B101f26750092C05350cF,\n      0xFC2d29Da710F45168DE11e5C051CaA558088D52a,\n      0x1C70B8160E92D56E550caf02e1f2e5EC0Fdb551A\n    ];\n  }\n}\n"
    },
    "contracts/ronin/profile/Profile.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./ProfileXComponents.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\n\npragma solidity ^0.8.9;\n\ncontract Profile is IProfile, ProfileXComponents, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  function initialize(address validatorContract) external initializer {\n    _setContract(ContractType.VALIDATOR, validatorContract);\n  }\n\n  function initializeV2(address stakingContract, address trustedOrgContract) external reinitializer(2) {\n    _setContract(ContractType.STAKING, stakingContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, trustedOrgContract);\n\n    TConsensus[] memory validatorCandidates = IRoninValidatorSet(getContract(ContractType.VALIDATOR))\n      .getValidatorCandidates();\n\n    for (uint256 i; i < validatorCandidates.length; ++i) {\n      TConsensus consensus = validatorCandidates[i];\n      address id = TConsensus.unwrap(consensus);\n      _consensus2Id[consensus] = id;\n    }\n\n    __migrationRenouncedCandidates();\n  }\n\n  function initializeV3(uint256 cooldown) external reinitializer(3) {\n    _setPubkeyChangeCooldown(cooldown);\n  }\n\n  /**\n   * @dev Add addresses of renounced candidates into registry. Only called during {initializeV2}.\n   */\n  function __migrationRenouncedCandidates() internal virtual {}\n\n\n  /**\n   * @dev This method is used in REP-4 migration, which creates profile for all community-validators and renounced validators.\n   * This method can be removed after REP-4 goes live.\n   *\n   * DO NOT use for any other purpose.\n   */\n  function __migrate(address id, address candidateAdmin, address treasury) internal {\n    CandidateProfile storage _profile = _id2Profile[id];\n    _profile.id = id;\n\n    _setConsensus(_profile, TConsensus.wrap(id));\n    _setAdmin(_profile, candidateAdmin);\n    _setTreasury(_profile, payable(treasury));\n    emit ProfileMigrated(id, candidateAdmin, treasury);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getId2Profile(address id) external view returns (CandidateProfile memory) {\n    return _id2Profile[id];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getManyId2Consensus(address[] calldata idList) external view returns (TConsensus[] memory consensusList) {\n    consensusList = new TConsensus[](idList.length);\n    unchecked {\n      for (uint i; i < idList.length; ++i) {\n        consensusList[i] = _id2Profile[idList[i]].consensus;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getConsensus2Id(TConsensus consensus) external view returns (address id) {\n    id = _consensus2Id[consensus];\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function getManyConsensus2Id(TConsensus[] calldata consensusList) external view returns (address[] memory idList) {\n    idList = new address[](consensusList.length);\n    unchecked {\n      for (uint i; i < consensusList.length; ++i) {\n        idList[i] = _consensus2Id[consensusList[i]];\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function addNewProfile(CandidateProfile memory profile) external onlyAdmin {\n    CandidateProfile storage _profile = _id2Profile[profile.id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n    _addNewProfile(_profile, profile);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update Staking contract:\n   *    + [x] Update (id => PoolDetail) mapping in {BaseStaking.sol}.\n   *    + [x] Update `_adminOfActivePoolMapping` in {BaseStaking.sol}.\n   * - Update Validator contract:\n   *    + [x] Update (id => ValidatorCandidate) mapping\n   */\n  function requestChangeAdminAddress(address id, address newAdminAddr) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonZeroAndNonDuplicated(RoleAccess.CANDIDATE_ADMIN, newAdminAddr);\n\n    IStaking stakingContract = IStaking(getContract(ContractType.STAKING));\n    stakingContract.execChangeAdminAddress(id, newAdminAddr);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeAdminAddress(id, newAdminAddr);\n\n    _setAdmin(_profile, newAdminAddr);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update in Staking contract for Consensus address mapping:\n   *   + [x] Keep the same previous pool address.\n   * - Update in Validator contract for:\n   *   + [x] Consensus Address mapping\n   *   + [x] Bridge Address mapping\n   *   + [x] Jail mapping\n   *   + [x] Pending reward mapping\n   *   + [x] Schedule mapping\n   * - Update in Slashing contract for:\n   *   + [x] Handling slash indicator\n   *   + [x] Handling slash fast finality\n   *   + [x] Handling slash double sign\n   * - Update in Proposal contract for:\n   *   + [-] Preserve the consensus address and recipient target of locked amount of emergency exit\n   * - Update Trusted Org contracts:\n   *   + [x] Remove and delete weight of the old consensus\n   *   + [x] Replace and add weight for the new consensus\n   */\n  function requestChangeConsensusAddr(address id, TConsensus newConsensusAddr) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, TConsensus.unwrap(newConsensusAddr));\n\n    TConsensus oldConsensusAddr = _profile.consensus;\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeConsensusAddress(id, newConsensusAddr);\n\n    IRoninTrustedOrganization trustedOrgContract = IRoninTrustedOrganization(\n      getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)\n    );\n    trustedOrgContract.execChangeConsensusAddressForTrustedOrg({\n      oldConsensusAddr: oldConsensusAddr,\n      newConsensusAddr: newConsensusAddr\n    });\n\n    _setConsensus(_profile, newConsensusAddr);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   *\n   * @dev Side-effects on other contracts:\n   * - Update Validator contract:\n   *    + [x] Update (id => ValidatorCandidate) mapping\n   * - Update governance admin:\n   *    + [-] Update recipient in the EmergencyExitBallot to the newTreasury.\n   *          Cannot impl since we cannot cancel the previous the ballot and\n   *          create a new ballot on behalf of the validator contract.\n   */\n  function requestChangeTreasuryAddr(address id, address payable newTreasury) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonZeroAndNonDuplicated(RoleAccess.TREASURY, newTreasury);\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    validatorContract.execChangeTreasuryAddress(id, newTreasury);\n\n    _setTreasury(_profile, newTreasury);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function changePubkey(address id, bytes calldata pubkey, bytes calldata proofOfPossession) external {\n    CandidateProfile storage _profile = _getId2ProfileHelper(id);\n    _requireCandidateAdmin(_profile);\n    _requireNonDuplicatedPubkey(pubkey);\n    _checkPubkeyChangeCooldown(_profile);\n    _verifyPubkey(pubkey, proofOfPossession);\n    _setPubkey(_profile, pubkey);\n  }\n\n  function _requireCandidateAdmin(CandidateProfile storage sProfile) internal view {\n    if (\n      msg.sender != sProfile.admin ||\n      !IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isCandidateAdmin(sProfile.consensus, msg.sender)\n    ) revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function setPubkeyChangeCooldown(uint256 cooldown) external onlyAdmin {\n    _setPubkeyChangeCooldown(cooldown);\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileHandler.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../udvts/Types.sol\";\nimport \"../../utils/RoleAccess.sol\";\nimport { ProfileStorage } from \"./ProfileStorage.sol\";\nimport { PCUVerifyBLSPublicKey } from \"../../precompile-usages/PCUVerifyBLSPublicKey.sol\";\n\nabstract contract ProfileHandler is PCUVerifyBLSPublicKey, ProfileStorage {\n  /**\n   * @dev Checks each element in the new profile and reverts if there is duplication with any existing profile.\n   */\n  function _requireNonDuplicatedInRegistry(CandidateProfile memory profile) internal view {\n    _requireNonZeroAndNonDuplicated(RoleAccess.CONSENSUS, TConsensus.unwrap(profile.consensus));\n    _requireNonZeroAndNonDuplicated(RoleAccess.CANDIDATE_ADMIN, profile.admin);\n    _requireNonZeroAndNonDuplicated(RoleAccess.TREASURY, profile.treasury);\n    _requireNonDuplicated(RoleAccess.TREASURY, profile.__reservedGovernor);\n    _requireNonDuplicatedPubkey(profile.pubkey);\n  }\n\n  function _requireNonZeroAndNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (addr == address(0)) revert ErrZeroAddress(addressType);\n    _requireNonDuplicated(addressType, addr);\n  }\n\n  function _requireNonDuplicated(RoleAccess addressType, address addr) internal view {\n    if (_isRegisteredAddr(addr)) {\n      revert ErrDuplicatedInfo(addressType, uint256(uint160(addr)));\n    }\n  }\n\n  function _isRegisteredAddr(address addr) internal view returns (bool) {\n    return _registry[uint256(uint160(addr))];\n  }\n\n  function _requireNonDuplicatedPubkey(bytes memory pubkey) internal view {\n    if (_isRegisteredPubkey(pubkey)) {\n      revert ErrDuplicatedPubkey(pubkey);\n    }\n  }\n\n  function _isRegisteredPubkey(bytes memory pubkey) internal view returns (bool) {\n    return _registry[_hashPubkey(pubkey)];\n  }\n\n  function _verifyPubkey(bytes calldata publicKey, bytes calldata proofOfPossession) internal {\n    if (!_pcVerifyBLSPublicKey(publicKey, proofOfPossession)) {\n      revert ErrInvalidProofOfPossession(publicKey, proofOfPossession);\n    } else {\n      emit PubkeyVerified(publicKey, proofOfPossession);\n    }\n  }\n\n  function _checkPubkeyChangeCooldown(CandidateProfile storage profile) internal view {\n    if (block.timestamp <= profile.pubkeyLastChange + pubkeyChangeCooldown) {\n      revert ErrPubkeyChangeCooldownNotEnded();\n    }\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../udvts/Types.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../utils/RoleAccess.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\n\nabstract contract ProfileStorage is IProfile, HasContracts {\n  /// @dev Mapping from id address => candidate profile.\n  mapping(address => CandidateProfile) internal _id2Profile;\n\n  /**\n   * @dev Mapping from any address or keccak256(pubkey) => whether it is already registered.\n   * This registry can only be toggled to `true` and NOT vice versa. All registered values\n   * cannot be reused.\n   */\n  mapping(uint256 => bool) internal _registry;\n\n  /// @dev Mapping from consensus address => id address.\n  mapping(TConsensus => address) internal _consensus2Id;\n\n  /// @dev The cooldown time the change public key.\n  uint256 pubkeyChangeCooldown;\n\n  /// @dev Upgradeable gap.\n  bytes32[47] __gap;\n\n  /**\n   * @dev Add a profile from memory to storage.\n   */\n  function _addNewProfile(CandidateProfile storage _profile, CandidateProfile memory newProfile) internal {\n    _profile.id = newProfile.id;\n\n    _setConsensus(_profile, newProfile.consensus);\n    _setAdmin(_profile, newProfile.admin);\n    _setTreasury(_profile, newProfile.treasury);\n    _setGovernor(_profile, newProfile.__reservedGovernor);\n    _setPubkey(_profile, newProfile.pubkey);\n\n    emit ProfileAdded(newProfile.id);\n  }\n\n  function _setConsensus(CandidateProfile storage _profile, TConsensus consensus) internal {\n    delete _consensus2Id[_profile.consensus];\n    _consensus2Id[consensus] = _profile.id;\n\n    _profile.consensus = consensus;\n    _registry[uint256(uint160(TConsensus.unwrap(consensus)))] = true;\n\n    emit ProfileAddressChanged(_profile.id, RoleAccess.CONSENSUS, TConsensus.unwrap(consensus));\n  }\n\n  function _setAdmin(CandidateProfile storage _profile, address admin) internal {\n    _profile.admin = admin;\n    _registry[uint256(uint160(admin))] = true;\n\n    emit ProfileAddressChanged(_profile.id, RoleAccess.CANDIDATE_ADMIN, admin);\n  }\n\n  function _setTreasury(CandidateProfile storage _profile, address payable treasury) internal {\n    _profile.treasury = treasury;\n    _registry[uint256(uint160(address(treasury)))] = true;\n\n    emit ProfileAddressChanged(_profile.id, RoleAccess.TREASURY, treasury);\n  }\n\n  /**\n   * @dev Allow to registry a profile without governor address since not all validators are governing validators.\n   */\n  function _setGovernor(CandidateProfile storage _profile, address governor) internal {\n    _profile.__reservedGovernor = governor;\n    if (governor != address(0)) {\n      _registry[uint256(uint160(governor))] = true;\n    }\n  }\n\n  function _setPubkey(CandidateProfile storage _profile, bytes memory pubkey) internal {\n    if (_profile.pubkey.length != 0) {\n      _profile.oldPubkey = _profile.pubkey;\n    }\n\n    _profile.pubkey = pubkey;\n    _profile.pubkeyLastChange = block.timestamp;\n    _registry[_hashPubkey(pubkey)] = true;\n\n    emit PubkeyChanged(_profile.id, pubkey);\n  }\n\n  /**\n   * @dev Get an existed profile struct from `id`. Revert if the profile does not exists.\n   */\n  function _getId2ProfileHelper(address id) internal view returns (CandidateProfile storage _profile) {\n    _profile = _id2Profile[id];\n    if (_profile.id == address(0)) revert ErrNonExistentProfile();\n  }\n\n  /**\n   * @dev Returns hash of a public key.\n   */\n  function _hashPubkey(bytes memory pubkey) internal pure returns (uint256) {\n    return uint256(keccak256(pubkey));\n  }\n\n  function _setPubkeyChangeCooldown(uint256 cooldown) internal {\n    pubkeyChangeCooldown = cooldown;\n  }\n}\n"
    },
    "contracts/ronin/profile/ProfileXComponents.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../../interfaces/IProfile.sol\";\nimport { ContractType } from \"../../utils/ContractType.sol\";\nimport \"./ProfileHandler.sol\";\n\npragma solidity ^0.8.9;\n\nabstract contract ProfileXComponents is IProfile, ProfileHandler {\n  /**\n   * @inheritdoc IProfile\n   */\n  function execApplyValidatorCandidate(\n    address admin,\n    address id,\n    address treasury,\n    bytes calldata pubkey,\n    bytes calldata proofOfPossession\n  ) external override onlyContract(ContractType.STAKING) {\n    // Check existent profile\n    CandidateProfile storage _profile = _id2Profile[id];\n    if (_profile.id != address(0)) revert ErrExistentProfile();\n\n    // Validate the info and add the profile\n    CandidateProfile memory profile = CandidateProfile({\n      id: id,\n      consensus: TConsensus.wrap(id),\n      admin: admin,\n      treasury: payable(treasury),\n      __reservedGovernor: address(0),\n      pubkey: pubkey,\n      pubkeyLastChange: 0,\n      oldPubkey: \"\"\n    });\n    _requireNonDuplicatedInRegistry(profile);\n    _verifyPubkey(pubkey, proofOfPossession);\n    _addNewProfile(_profile, profile);\n  }\n\n  /**\n   * @inheritdoc IProfile\n   */\n  function arePublicKeysRegistered(bytes[][2] calldata listOfPublicKey) external view returns (bool) {\n    for (uint256 i; i < listOfPublicKey.length; ) {\n      for (uint256 j; j < listOfPublicKey[i].length; ) {\n        if (!_isRegisteredPubkey(listOfPublicKey[i][j])) {\n          return false;\n        }\n\n        unchecked {\n          j++;\n        }\n      }\n\n      unchecked {\n        i++;\n      }\n    }\n\n    return true;\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/CreditScore.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ICreditScore.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated, HasMaintenanceDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrUnauthorized, RoleAccess } from \"../../utils/CommonErrors.sol\";\n\nabstract contract CreditScore is\n  ICreditScore,\n  HasContracts,\n  HasValidatorDeprecated,\n  HasMaintenanceDeprecated,\n  PercentageConsumer\n{\n  /// @dev Mapping from validator id => period index => whether bailed out before\n  mapping(address => mapping(uint256 => bool)) internal _checkBailedOutAtPeriod;\n  /// @dev Mapping from validator address => credit score\n  mapping(address => uint256) internal _creditScore;\n\n  /// @dev The max gained number of credit score per period.\n  uint256 internal _gainCreditScore;\n  /// @dev The max number of credit score that a validator can hold.\n  uint256 internal _maxCreditScore;\n  /// @dev The number that will be multiplied with the remaining jailed time to get the cost of bailing out.\n  uint256 internal _bailOutCostMultiplier;\n  /// @dev The percentage of reward to be cut off from the validator in the rest of the period after bailed out.\n  uint256 internal _cutOffPercentageAfterBailout;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function execUpdateCreditScores(\n    address[] calldata validatorIds,\n    uint256 period\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(msg.sender);\n    uint256 periodStartAtBlock = validatorContract.currentPeriodStartAtBlock();\n\n    bool[] memory jaileds = validatorContract.checkManyJailedById(validatorIds);\n    bool[] memory maintaineds = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintainedInBlockRangeById(\n      validatorIds,\n      periodStartAtBlock,\n      block.number\n    );\n    uint256[] memory updatedCreditScores = new uint256[](validatorIds.length);\n\n    for (uint i = 0; i < validatorIds.length; ) {\n      address vId = validatorIds[i];\n\n      uint256 indicator = _getUnavailabilityIndicatorById(vId, period);\n      bool isJailedInPeriod = jaileds[i];\n      bool isMaintainingInPeriod = maintaineds[i];\n\n      uint256 _actualGain = (isJailedInPeriod || isMaintainingInPeriod)\n        ? 0\n        : Math.subNonNegative(_gainCreditScore, indicator);\n\n      _creditScore[vId] = Math.addWithUpperbound(_creditScore[vId], _actualGain, _maxCreditScore);\n      updatedCreditScores[i] = _creditScore[vId];\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit CreditScoresUpdated(validatorIds, updatedCreditScores);\n  }\n\n  function execResetCreditScores(\n    address[] calldata validatorIds\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    uint256[] memory updatedCreditScores = new uint256[](validatorIds.length);\n    for (uint i = 0; i < validatorIds.length; ) {\n      address _validator = validatorIds[i];\n      delete _creditScore[_validator];\n      delete updatedCreditScores[i];\n\n      unchecked {\n        ++i;\n      }\n    }\n    emit CreditScoresUpdated(validatorIds, updatedCreditScores);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function bailOut(TConsensus consensusAddr) external override {\n    address validatorId = __css2cid(consensusAddr);\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    if (!validatorContract.isValidatorCandidate(consensusAddr))\n      revert ErrUnauthorized(msg.sig, RoleAccess.VALIDATOR_CANDIDATE);\n\n    if (!validatorContract.isCandidateAdmin(consensusAddr, msg.sender))\n      revert ErrUnauthorized(msg.sig, RoleAccess.CANDIDATE_ADMIN);\n\n    (bool isJailed, , uint256 jailedEpochLeft) = validatorContract.getJailedTimeLeft(consensusAddr);\n    if (!isJailed) revert ErrCallerMustBeJailedInTheCurrentPeriod();\n\n    uint256 period = validatorContract.currentPeriod();\n    if (_checkBailedOutAtPeriod[validatorId][period]) revert ErrValidatorHasBailedOutPreviously();\n\n    uint256 score = _creditScore[validatorId];\n    uint256 cost = jailedEpochLeft * _bailOutCostMultiplier;\n    if (score < cost) revert ErrInsufficientCreditScoreToBailOut();\n\n    validatorContract.execBailOut(validatorId, period);\n\n    _creditScore[validatorId] -= cost;\n    _setUnavailabilityIndicator(validatorId, period, 0);\n    _checkBailedOutAtPeriod[validatorId][period] = true;\n    emit BailedOut(validatorId, period, cost);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) external override onlyAdmin {\n    _setCreditScoreConfigs(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n\n  /**\n   * @dev See `ISlashUnavailability`\n   */\n  function _getUnavailabilityIndicatorById(address validator, uint256 period) internal view virtual returns (uint256);\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScoreConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 gainCreditScore_,\n      uint256 maxCreditScore_,\n      uint256 bailOutCostMultiplier_,\n      uint256 cutOffPercentageAfterBailout_\n    )\n  {\n    return (_gainCreditScore, _maxCreditScore, _bailOutCostMultiplier, _cutOffPercentageAfterBailout);\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getCreditScore(TConsensus consensusAddr) external view override returns (uint256) {\n    return _creditScore[__css2cid(consensusAddr)];\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function getManyCreditScores(\n    TConsensus[] calldata consensusAddrs\n  ) public view override returns (uint256[] memory resultList) {\n    address[] memory validatorIds = __css2cidBatch(consensusAddrs);\n    resultList = new uint256[](validatorIds.length);\n\n    for (uint i = 0; i < resultList.length; ) {\n      resultList[i] = _creditScore[validatorIds[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICreditScore\n   */\n  function checkBailedOutAtPeriod(TConsensus consensus, uint256 period) external view override returns (bool) {\n    return _checkBailedOutAtPeriodById(__css2cid(consensus), period);\n  }\n\n  function _checkBailedOutAtPeriodById(address validatorId, uint256 period) internal view virtual returns (bool) {\n    return _checkBailedOutAtPeriod[validatorId][period];\n  }\n\n  /**\n   * @dev See `SlashUnavailability`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 period, uint256 _indicator) internal virtual;\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n\n  /**\n   * @dev See `ICreditScore-setCreditScoreConfigs`.\n   */\n  function _setCreditScoreConfigs(\n    uint256 _gainScore,\n    uint256 _maxScore,\n    uint256 _bailOutMultiplier,\n    uint256 _cutOffPercentage\n  ) internal {\n    if (_gainScore > _maxScore) revert ErrInvalidCreditScoreConfig();\n    if (_cutOffPercentage > _MAX_PERCENTAGE) revert ErrInvalidCutOffPercentageConfig();\n\n    _gainCreditScore = _gainScore;\n    _maxCreditScore = _maxScore;\n    _bailOutCostMultiplier = _bailOutMultiplier;\n    _cutOffPercentageAfterBailout = _cutOffPercentage;\n    emit CreditScoreConfigsUpdated(_gainScore, _maxScore, _bailOutMultiplier, _cutOffPercentage);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/DeprecatedSlashBridgeOperator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../extensions/collections/HasProxyAdmin.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract DeprecatedSlashBridgeOperator is\n  HasProxyAdmin,\n  HasContracts,\n  HasValidatorDeprecated,\n  PercentageConsumer\n{\n  /**\n   * @dev The bridge operators will be deprecated reward if (s)he missed more than the ratio.\n   * Values 0-10,000 map to 0%-100%.\n   */\n  uint256 private ____deprecatedMissingVotesRatioTier1;\n  /**\n   * @dev The bridge operators will be deprecated all rewards including bridge reward and mining reward if (s)he missed\n   * more than the ratio. Values 0-10,000 map to 0%-100%.\n   */\n  uint256 private ____deprecatedMissingVotesRatioTier2;\n  /// @dev The number of blocks to jail the corresponding block producer when its bridge operator is slashed tier-2.\n  uint256 private ____deprecatedJailDurationForMissingVotesRatioTier2;\n  /// @dev The threshold to skip slashing the bridge operator in case the total number of votes in the bridge is too small.\n  uint256 private ____deprecatedSkipBridgeOperatorSlashingThreshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ronin/slash-indicator/DeprecatedSlashBridgeVoting.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport { HasValidatorDeprecated, HasTrustedOrgDeprecated, HasGovernanceAdminDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\n\n// TODO: remove this from slashing logic of consensus contract\nabstract contract DeprecatedSlashBridgeVoting is\n  HasContracts,\n  HasValidatorDeprecated,\n  HasTrustedOrgDeprecated,\n  HasGovernanceAdminDeprecated\n{\n  /// @dev Mapping from validator address => period index => bridge voting slashed\n  mapping(address => mapping(uint256 => bool)) private __deprecatedBridgeVotingSlashed;\n  /// @dev The threshold to slash when a trusted organization does not vote for bridge operators.\n  uint256 private __deprecatedBridgeVotingThreshold;\n  /// @dev The amount of RON to slash bridge voting.\n  uint256 private __deprecatedBridgeVotingSlashAmount;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashDoubleSign.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashDoubleSign.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../precompile-usages/PCUValidateDoubleSign.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract SlashDoubleSign is ISlashDoubleSign, HasContracts, HasValidatorDeprecated, PCUValidateDoubleSign {\n  /// @dev The amount of RON to slash double sign.\n  uint256 internal _slashDoubleSignAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to double signing.\n  uint256 internal _doubleSigningJailUntilBlock;\n  /** @dev The offset from the submitted block to the current block, from which double signing will be invalidated.\n   * This parameter is exposed for system transaction.\n   **/\n  uint256 internal _doubleSigningOffsetLimitBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) _submittedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[24] private ______gap;\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function slashDoubleSign(\n    TConsensus consensusAddr,\n    bytes calldata header1,\n    bytes calldata header2\n  ) external override onlyAdmin {\n    bytes32 header1Checksum = keccak256(header1);\n    bytes32 header2Checksum = keccak256(header2);\n\n    if (_submittedEvidence[header1Checksum] || _submittedEvidence[header2Checksum]) {\n      revert ErrEvidenceAlreadySubmitted();\n    }\n\n    address validatorId = __css2cid(consensusAddr);\n\n    // NOTE: Edge case: non-validator who never apply for the candidate role, nor have a profile.\n    // Must be slashed by the consensus address, since the validatorId will be address(0).\n    if (validatorId == address(0)) {\n      validatorId = TConsensus.unwrap(consensusAddr);\n    }\n\n    if (_pcValidateEvidence(validatorId, header1, header2)) {\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      _submittedEvidence[header1Checksum] = true;\n      _submittedEvidence[header2Checksum] = true;\n      emit Slashed(validatorId, SlashType.DOUBLE_SIGNING, period);\n      validatorContract.execSlash(validatorId, _doubleSigningJailUntilBlock, _slashDoubleSignAmount, true);\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function getDoubleSignSlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 slashDoubleSignAmount_,\n      uint256 doubleSigningJailUntilBlock_,\n      uint256 doubleSigningOffsetLimitBlock_\n    )\n  {\n    return (_slashDoubleSignAmount, _doubleSigningJailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashDoubleSign\n   */\n  function setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) external override onlyAdmin {\n    _setDoubleSignSlashingConfigs(_slashAmount, _jailUntilBlock, _offsetLimitBlock);\n  }\n\n  /**\n   * @dev See `ISlashDoubleSign-setDoubleSignSlashingConfigs`.\n   */\n  function _setDoubleSignSlashingConfigs(\n    uint256 _slashAmount,\n    uint256 _jailUntilBlock,\n    uint256 _offsetLimitBlock\n  ) internal {\n    _slashDoubleSignAmount = _slashAmount;\n    _doubleSigningJailUntilBlock = _jailUntilBlock;\n    _doubleSigningOffsetLimitBlock = _offsetLimitBlock;\n    emit DoubleSignSlashingConfigsUpdated(_slashAmount, _jailUntilBlock, _doubleSigningOffsetLimitBlock);\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(TConsensus consensus, address validatorId) internal view virtual returns (bool);\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashFastFinality.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/slash-indicator/ISlashFastFinality.sol\";\nimport { IRoninValidatorSet } from \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport { IProfile } from \"../../interfaces/IProfile.sol\";\nimport { IRoninTrustedOrganization } from \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../precompile-usages/PCUValidateFastFinality.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashFastFinality is ISlashFastFinality, HasContracts, PCUValidateFastFinality {\n  /// @dev The amount of RON to slash fast finality.\n  uint256 internal _slashFastFinalityAmount;\n  /// @dev The block number that the punished validator will be jailed until, due to malicious fast finality.\n  uint256 internal _fastFinalityJailUntilBlock;\n  /// @dev Recording of submitted proof to prevent relay attack.\n  mapping(bytes32 => bool) internal _processedEvidence;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[21] private ______gap;\n\n  modifier onlyGoverningValidator() {\n    if (_getGovernorWeight(msg.sender) == 0) revert ErrUnauthorized(msg.sig, RoleAccess.GOVERNOR);\n    _;\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function slashFastFinality(\n    TConsensus consensusAddr,\n    bytes calldata voterPublicKey,\n    uint256 targetBlockNumber,\n    bytes32[2] calldata targetBlockHash,\n    bytes[][2] calldata listOfPublicKey,\n    bytes[2] calldata aggregatedSignature\n  ) external override onlyGoverningValidator {\n    address validatorId = __css2cid(consensusAddr);\n    IProfile profileContract = IProfile(getContract(ContractType.PROFILE));\n\n    IProfile.CandidateProfile memory profile = profileContract.getId2Profile(validatorId);\n    bytes32 voterPublicKeyHash = keccak256(voterPublicKey);\n    if (\n      (voterPublicKeyHash != keccak256(profile.pubkey)) &&\n      (voterPublicKeyHash != keccak256(profile.oldPubkey))\n    ) {\n      revert ErrInvalidArguments(msg.sig);\n    }\n\n    bytes32 evidenceHash = keccak256(abi.encodePacked(consensusAddr, targetBlockNumber));\n    if (_processedEvidence[evidenceHash]) revert ErrEvidenceAlreadySubmitted();\n\n    if (!profileContract.arePublicKeysRegistered(listOfPublicKey)) {\n      revert ErrUnregisteredPublicKey();\n    }\n\n    if (\n      _pcValidateFastFinalityEvidence(\n        voterPublicKey,\n        targetBlockNumber,\n        targetBlockHash,\n        listOfPublicKey,\n        aggregatedSignature\n      )\n    ) {\n      _processedEvidence[evidenceHash] = true;\n\n      IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n      uint256 period = validatorContract.currentPeriod();\n      emit Slashed(validatorId, SlashType.FAST_FINALITY, period);\n      validatorContract.execSlash({\n        cid: validatorId,\n        newJailedUntil: _fastFinalityJailUntilBlock,\n        slashAmount: _slashFastFinalityAmount,\n        cannotBailout: true\n      });\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function getFastFinalitySlashingConfigs()\n    external\n    view\n    override\n    returns (uint256 slashFastFinalityAmount_, uint256 fastFinalityJailUntilBlock_)\n  {\n    return (_slashFastFinalityAmount, _fastFinalityJailUntilBlock);\n  }\n\n  /**\n   * @inheritdoc ISlashFastFinality\n   */\n  function setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) external override onlyAdmin {\n    _setFastFinalitySlashingConfigs(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev See `ISlashFastFinality-setFastFinalitySlashingConfigs`.\n   */\n  function _setFastFinalitySlashingConfigs(uint256 slashAmount, uint256 jailUntilBlock) internal {\n    _slashFastFinalityAmount = slashAmount;\n    _fastFinalityJailUntilBlock = jailUntilBlock;\n    emit FastFinalitySlashingConfigsUpdated(slashAmount, jailUntilBlock);\n  }\n\n  /**\n   * @dev Get governor, i.e. governing validator's weight, of the `addr`.\n   */\n  function _getGovernorWeight(address addr) internal view returns (uint256) {\n    return IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getGovernorWeight(addr);\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashIndicator.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./DeprecatedSlashBridgeOperator.sol\";\nimport \"./DeprecatedSlashBridgeVoting.sol\";\nimport \"./SlashDoubleSign.sol\";\nimport \"./SlashFastFinality.sol\";\nimport \"./SlashUnavailability.sol\";\nimport \"./CreditScore.sol\";\n\ncontract SlashIndicator is\n  ISlashIndicator,\n  SlashDoubleSign,\n  SlashFastFinality,\n  DeprecatedSlashBridgeVoting,\n  DeprecatedSlashBridgeOperator,\n  SlashUnavailability,\n  CreditScore,\n  Initializable\n{\n  constructor() {\n    _disableInitializers();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address __roninGovernanceAdminContract,\n    uint256[4] calldata /* _bridgeOperatorSlashingConfigs */,\n    uint256[2] calldata /* _bridgeVotingSlashingConfigs */,\n    // _doubleSignSlashingConfigs[0]: _slashDoubleSignAmount\n    // _doubleSignSlashingConfigs[1]: _doubleSigningJailUntilBlock\n    // _doubleSignSlashingConfigs[2]: _doubleSigningOffsetLimitBlock\n    uint256[3] calldata _doubleSignSlashingConfigs,\n    // _unavailabilitySlashingConfigs[0]: _unavailabilityTier1Threshold\n    // _unavailabilitySlashingConfigs[1]: _unavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[2]: _slashAmountForUnavailabilityTier2Threshold\n    // _unavailabilitySlashingConfigs[3]: _jailDurationForUnavailabilityTier2Threshold\n    uint256[4] calldata _unavailabilitySlashingConfigs,\n    // _creditScoreConfigs[0]: _gainCreditScore\n    // _creditScoreConfigs[1]: _maxCreditScore\n    // _creditScoreConfigs[2]: _bailOutCostMultiplier\n    // _creditScoreConfigs[3]: _cutOffPercentageAfterBailout\n    uint256[4] calldata _creditScoreConfigs\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, __validatorContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.GOVERNANCE_ADMIN, __roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setDoubleSignSlashingConfigs(\n      _doubleSignSlashingConfigs[0],\n      _doubleSignSlashingConfigs[1],\n      _doubleSignSlashingConfigs[2]\n    );\n    _setUnavailabilitySlashingConfigs(\n      _unavailabilitySlashingConfigs[0],\n      _unavailabilitySlashingConfigs[1],\n      _unavailabilitySlashingConfigs[2],\n      _unavailabilitySlashingConfigs[3]\n    );\n    _setCreditScoreConfigs(\n      _creditScoreConfigs[0],\n      _creditScoreConfigs[1],\n      _creditScoreConfigs[2],\n      _creditScoreConfigs[3]\n    );\n  }\n\n  function initializeV2(address roninGovernanceAdminContract) external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.GOVERNANCE_ADMIN, roninGovernanceAdminContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedValidator;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedTrustedOrg;\n    delete ______deprecatedGovernanceAdmin;\n  }\n\n  function initializeV3(address profileContract) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, profileContract);\n    _setFastFinalitySlashingConfigs(_slashDoubleSignAmount, _doubleSigningJailUntilBlock);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to reset the indicator of the validator after bailing out.\n   */\n  function _setUnavailabilityIndicator(\n    address validator,\n    uint256 period,\n    uint256 indicator\n  ) internal override(CreditScore, SlashUnavailability) {\n    SlashUnavailability._setUnavailabilityIndicator(validator, period, indicator);\n  }\n\n  /**\n   * @dev Helper for CreditScore contract to query indicator of the validator.\n   */\n  function _getUnavailabilityIndicatorById(\n    address validatorId,\n    uint256 period\n  ) internal view override(CreditScore, SlashUnavailability) returns (uint256) {\n    return SlashUnavailability._getUnavailabilityIndicatorById(validatorId, period);\n  }\n\n  function _checkBailedOutAtPeriodById(\n    address cid,\n    uint256 period\n  ) internal view override(CreditScore, SlashUnavailability) returns (bool) {\n    return CreditScore._checkBailedOutAtPeriodById(cid, period);\n  }\n\n  /**\n   * @dev Sanity check the address to be slashed\n   */\n  function _shouldSlash(\n    TConsensus consensus,\n    address validatorId\n  ) internal view override(SlashDoubleSign, SlashUnavailability) returns (bool) {\n    return\n      (msg.sender != TConsensus.unwrap(consensus)) &&\n      (msg.sender != validatorId) &&\n      IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isBlockProducer(consensus) &&\n      !IMaintenance(getContract(ContractType.MAINTENANCE)).checkMaintainedById(validatorId, block.number);\n  }\n\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view override(CreditScore, SlashDoubleSign, SlashUnavailability, SlashFastFinality) returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view override returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n}\n"
    },
    "contracts/ronin/slash-indicator/SlashUnavailability.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"./CreditScore.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/slash-indicator/ISlashUnavailability.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport { ErrInvalidThreshold } from \"../../utils/CommonErrors.sol\";\n\nabstract contract SlashUnavailability is ISlashUnavailability, HasContracts, HasValidatorDeprecated {\n  /// @dev The last block that a validator is slashed for unavailability.\n  uint256 internal _lastUnavailabilitySlashedBlock;\n  /// @dev Mapping from validator address => period index => unavailability indicator.\n  mapping(address => mapping(uint256 => uint256)) internal _unavailabilityIndicator;\n\n  /**\n   * @dev The mining reward will be deprecated, if (s)he missed more than this threshold.\n   * This threshold is applied for tier-1 and tier-3 of unavailability slash.\n   */\n  uint256 internal _unavailabilityTier1Threshold;\n  /**\n   * @dev The mining reward will be deprecated, (s)he will be put in jailed, and will be deducted\n   * self-staking if (s)he misses more than this threshold. This threshold is applied for tier-2 slash.\n   */\n  uint256 internal _unavailabilityTier2Threshold;\n  /**\n   * @dev The amount of RON to deduct from self-staking of a block producer when (s)he is slashed with\n   * tier-2 or tier-3.\n   **/\n  uint256 internal _slashAmountForUnavailabilityTier2Threshold;\n  /// @dev The number of blocks to jail a block producer when (s)he is slashed with tier-2 or tier-3.\n  uint256 internal _jailDurationForUnavailabilityTier2Threshold;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  modifier oncePerBlock() {\n    if (block.number <= _lastUnavailabilitySlashedBlock) {\n      revert ErrCannotSlashAValidatorTwiceOrSlashMoreThanOneValidatorInOneBlock();\n    }\n\n    _lastUnavailabilitySlashedBlock = block.number;\n    _;\n  }\n\n  function lastUnavailabilitySlashedBlock() external view returns (uint256) {\n    return _lastUnavailabilitySlashedBlock;\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function slashUnavailability(TConsensus consensusAddr) external override oncePerBlock {\n    if (msg.sender != block.coinbase) revert ErrUnauthorized(msg.sig, RoleAccess.COINBASE);\n\n    address validatorId = __css2cid(consensusAddr);\n    if (!_shouldSlash(consensusAddr, validatorId)) {\n      // Should return instead of throwing error since this is a part of system transaction.\n      return;\n    }\n\n    IRoninValidatorSet _validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    uint256 period = _validatorContract.currentPeriod();\n    uint256 count;\n    unchecked {\n      count = ++_unavailabilityIndicator[validatorId][period];\n    }\n    uint256 newJailedUntilBlock = Math.addIfNonZero(block.number, _jailDurationForUnavailabilityTier2Threshold);\n\n    if (count == _unavailabilityTier2Threshold) {\n      emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_2, period);\n      _validatorContract.execSlash(\n        validatorId,\n        newJailedUntilBlock,\n        _slashAmountForUnavailabilityTier2Threshold,\n        false\n      );\n    } else if (count == _unavailabilityTier1Threshold) {\n      bool tier1SecondTime = _checkBailedOutAtPeriodById(validatorId, period);\n      if (!tier1SecondTime) {\n        emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_1, period);\n        _validatorContract.execSlash(validatorId, 0, 0, false);\n      } else {\n        /// Handles tier-3\n        emit Slashed(validatorId, SlashType.UNAVAILABILITY_TIER_3, period);\n        _validatorContract.execSlash(\n          validatorId,\n          newJailedUntilBlock,\n          _slashAmountForUnavailabilityTier2Threshold,\n          true\n        );\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) external override onlyAdmin {\n    _setUnavailabilitySlashingConfigs(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilitySlashingConfigs()\n    external\n    view\n    override\n    returns (\n      uint256 unavailabilityTier1Threshold_,\n      uint256 unavailabilityTier2Threshold_,\n      uint256 slashAmountForUnavailabilityTier2Threshold_,\n      uint256 jailDurationForUnavailabilityTier2Threshold_\n    )\n  {\n    return (\n      _unavailabilityTier1Threshold,\n      _unavailabilityTier2Threshold,\n      _slashAmountForUnavailabilityTier2Threshold,\n      _jailDurationForUnavailabilityTier2Threshold\n    );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function currentUnavailabilityIndicator(TConsensus consensus) external view override returns (uint256) {\n    return\n      _getUnavailabilityIndicatorById(\n        __css2cid(consensus),\n        IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod()\n      );\n  }\n\n  /**\n   * @inheritdoc ISlashUnavailability\n   */\n  function getUnavailabilityIndicator(\n    TConsensus consensus,\n    uint256 period\n  ) external view virtual override returns (uint256) {\n    return _getUnavailabilityIndicatorById(__css2cid(consensus), period);\n  }\n\n  function _getUnavailabilityIndicatorById(\n    address validatorId,\n    uint256 period\n  ) internal view virtual returns (uint256) {\n    return _unavailabilityIndicator[validatorId][period];\n  }\n\n  /**\n   * @dev Sets the unavailability indicator of the `_validator` at `_period`.\n   */\n  function _setUnavailabilityIndicator(address _validator, uint256 _period, uint256 _indicator) internal virtual {\n    _unavailabilityIndicator[_validator][_period] = _indicator;\n  }\n\n  /**\n   * @dev See `ISlashUnavailability-setUnavailabilitySlashingConfigs`.\n   */\n  function _setUnavailabilitySlashingConfigs(\n    uint256 _tier1Threshold,\n    uint256 _tier2Threshold,\n    uint256 _slashAmountForTier2Threshold,\n    uint256 _jailDurationForTier2Threshold\n  ) internal {\n    if (_unavailabilityTier1Threshold > _unavailabilityTier2Threshold) revert ErrInvalidThreshold(msg.sig);\n\n    _unavailabilityTier1Threshold = _tier1Threshold;\n    _unavailabilityTier2Threshold = _tier2Threshold;\n    _slashAmountForUnavailabilityTier2Threshold = _slashAmountForTier2Threshold;\n    _jailDurationForUnavailabilityTier2Threshold = _jailDurationForTier2Threshold;\n    emit UnavailabilitySlashingConfigsUpdated(\n      _tier1Threshold,\n      _tier2Threshold,\n      _slashAmountForTier2Threshold,\n      _jailDurationForTier2Threshold\n    );\n  }\n\n  /**\n   * @dev Returns whether the account `_addr` should be slashed or not.\n   */\n  function _shouldSlash(TConsensus consensus, address validatorId) internal view virtual returns (bool);\n\n  /**\n   * @dev See `ICreditScore-checkBailedOutAtPeriodById`\n   */\n  function _checkBailedOutAtPeriodById(address validatorId, uint256 period) internal view virtual returns (bool);\n\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n}\n"
    },
    "contracts/ronin/staking/BaseStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/staking/IBaseStaking.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasValidatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"./RewardCalculation.sol\";\nimport { TPoolId, TConsensus } from \"../../udvts/Types.sol\";\n\nabstract contract BaseStaking is\n  RONTransferHelper,\n  ReentrancyGuard,\n  RewardCalculation,\n  HasContracts,\n  IBaseStaking,\n  HasValidatorDeprecated\n{\n  /// @dev Mapping from pool address (i.e. validator id) => staking pool detail\n  mapping(address => PoolDetail) internal _poolDetail;\n\n  /// @dev The cooldown time in seconds to undelegate from the last timestamp (s)he delegated.\n  uint256 internal _cooldownSecsToUndelegate;\n  /// @dev The number of seconds that a candidate must wait to be revoked and take the self-staking amount back.\n  uint256 internal _waitingSecsToRevoke;\n\n  /// @dev Mapping from \"admin address of an active pool\" => \"pool id\".\n  mapping(address => address) internal _adminOfActivePoolMapping;\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  modifier noEmptyValue() {\n    _requireValue();\n    _;\n  }\n\n  modifier anyExceptPoolAdmin(PoolDetail storage _pool, address delegator) {\n    _anyExceptPoolAdmin(_pool, delegator);\n    _;\n  }\n\n  modifier onlyPoolAdmin(PoolDetail storage _pool, address requester) {\n    _requirePoolAdmin(_pool, requester);\n    _;\n  }\n\n  modifier poolOfConsensusIsActive(TConsensus consensusAddr) {\n    _poolOfConsensusIsActive(consensusAddr);\n    _;\n  }\n\n  function _requireValue() private view {\n    if (msg.value == 0) revert ErrZeroValue();\n  }\n\n  function _requirePoolAdmin(PoolDetail storage _pool, address requester) private view {\n    if (_pool.__shadowedPoolAdmin != requester) revert ErrOnlyPoolAdminAllowed();\n  }\n\n  function _anyExceptPoolAdmin(PoolDetail storage _pool, address delegator) private view {\n    if (_pool.__shadowedPoolAdmin == delegator) revert ErrPoolAdminForbidden();\n  }\n\n  function _poolOfConsensusIsActive(TConsensus consensusAddr) private view {\n    if (!IRoninValidatorSet(getContract(ContractType.VALIDATOR)).isValidatorCandidate(consensusAddr))\n      revert ErrInactivePool(consensusAddr, __css2cid(consensusAddr));\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function isAdminOfActivePool(address admin) public view override returns (bool) {\n    return _adminOfActivePoolMapping[admin] != address(0);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getPoolAddressOf(address admin) external view override returns (address) {\n    return _adminOfActivePoolMapping[admin];\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getPoolDetail(\n    TConsensus consensusAddr\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal) {\n    address poolId = __css2cid(consensusAddr);\n    return _getPoolDetailById(poolId);\n  }\n\n  function getPoolDetailById(\n    address poolId\n  ) external view returns (address admin, uint256 stakingAmount, uint256 stakingTotal) {\n    return _getPoolDetailById(poolId);\n  }\n\n  function _getPoolDetailById(\n    address poolId\n  ) internal view returns (address admin, uint256 stakingAmount, uint256 stakingTotal) {\n    PoolDetail storage _pool = _poolDetail[poolId];\n    return (_pool.__shadowedPoolAdmin, _pool.stakingAmount, _pool.stakingTotal);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getManySelfStakings(\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory selfStakings_) {\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    return _getManySelfStakingsById(poolIds);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function getManySelfStakingsById(address[] calldata poolIds) external view returns (uint256[] memory selfStakings_) {\n    return _getManySelfStakingsById(poolIds);\n  }\n\n  /**\n   * @dev Query many self staking amount by list `poolIds`.\n   */\n  function _getManySelfStakingsById(address[] memory poolIds) internal view returns (uint256[] memory selfStakings_) {\n    selfStakings_ = new uint256[](poolIds.length);\n    for (uint i = 0; i < poolIds.length; ) {\n      selfStakings_[i] = _poolDetail[poolIds[i]].stakingAmount;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingTotal(TConsensus consensusAddr) external view override returns (uint256) {\n    address poolId = __css2cid(consensusAddr);\n    return _getStakingTotal(poolId);\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingTotals(\n    TConsensus[] calldata consensusAddrs\n  ) external view override returns (uint256[] memory stakingAmounts_) {\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    return _getManyStakingTotalsById(poolIds);\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingTotalsById(\n    address[] calldata poolIds\n  ) external view override returns (uint256[] memory stakingAmounts_) {\n    return _getManyStakingTotalsById(poolIds);\n  }\n\n  function _getManyStakingTotalsById(\n    address[] memory poolIds\n  ) internal view returns (uint256[] memory stakingAmounts_) {\n    stakingAmounts_ = new uint256[](poolIds.length);\n    for (uint i = 0; i < poolIds.length; ) {\n      stakingAmounts_[i] = _getStakingTotal(poolIds[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _getStakingTotal(address poolId) internal view override returns (uint256) {\n    return _poolDetail[poolId].stakingTotal;\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getStakingAmount(TConsensus consensusAddr, address user) external view override returns (uint256) {\n    address poolId = __css2cid(consensusAddr);\n    return _getStakingAmount(poolId, user);\n  }\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getManyStakingAmounts(\n    TConsensus[] calldata consensusAddrs,\n    address[] calldata userList\n  ) external view override returns (uint256[] memory stakingAmounts) {\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    return _getManyStakingAmountsById(poolIds, userList);\n  }\n\n  function getManyStakingAmountsById(\n    address[] calldata poolIds,\n    address[] calldata userList\n  ) external view returns (uint256[] memory stakingAmounts) {\n    return _getManyStakingAmountsById(poolIds, userList);\n  }\n\n  function _getManyStakingAmountsById(\n    address[] memory poolIds,\n    address[] memory userList\n  ) internal view returns (uint256[] memory stakingAmounts) {\n    if (poolIds.length != userList.length) revert ErrInvalidArrays();\n    stakingAmounts = new uint256[](poolIds.length);\n    for (uint i = 0; i < stakingAmounts.length; ) {\n      stakingAmounts[i] = _getStakingAmount(poolIds[i], userList[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  function _getStakingAmount(address poolId, address user) internal view override returns (uint256) {\n    return _poolDetail[poolId].delegatingAmount[user];\n  }\n\n  function __css2cid(TConsensus consensusAddr) internal view returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function cooldownSecsToUndelegate() external view returns (uint256) {\n    return _cooldownSecsToUndelegate;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function waitingSecsToRevoke() external view returns (uint256) {\n    return _waitingSecsToRevoke;\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function setCooldownSecsToUndelegate(uint256 cooldownSecs) external override onlyAdmin {\n    _setCooldownSecsToUndelegate(cooldownSecs);\n  }\n\n  /**\n   * @inheritdoc IBaseStaking\n   */\n  function setWaitingSecsToRevoke(uint256 secs) external override onlyAdmin {\n    _setWaitingSecsToRevoke(secs);\n  }\n\n  /**\n   * @dev Sets the minium number of seconds to undelegate.\n   *\n   * Emits the event `CooldownSecsToUndelegateUpdated`.\n   *\n   */\n  function _setCooldownSecsToUndelegate(uint256 cooldownSecs) internal {\n    _cooldownSecsToUndelegate = cooldownSecs;\n    emit CooldownSecsToUndelegateUpdated(cooldownSecs);\n  }\n\n  /**\n   * @dev Sets the number of seconds that a candidate must wait to be revoked.\n   *\n   * Emits the event `WaitingSecsToRevokeUpdated`.\n   *\n   */\n  function _setWaitingSecsToRevoke(uint256 secs) internal {\n    _waitingSecsToRevoke = secs;\n    emit WaitingSecsToRevokeUpdated(secs);\n  }\n\n  /**\n   * @dev Changes the delegate amount.\n   */\n  function _changeDelegatingAmount(\n    PoolDetail storage _pool,\n    address delegator,\n    uint256 newDelegatingAmount,\n    uint256 newStakingTotal\n  ) internal {\n    _syncUserReward(_pool.pid, delegator, newDelegatingAmount);\n    _pool.stakingTotal = newStakingTotal;\n    _pool.delegatingAmount[delegator] = newDelegatingAmount;\n  }\n}\n"
    },
    "contracts/ronin/staking/CandidateStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../libraries/AddressArrayUtils.sol\";\nimport \"../../interfaces/staking/ICandidateStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"./BaseStaking.sol\";\n\nabstract contract CandidateStaking is BaseStaking, ICandidateStaking, GlobalConfigConsumer, PercentageConsumer {\n  /// @dev The minimum threshold for being a validator candidate.\n  uint256 internal _minValidatorStakingAmount;\n\n  /// @dev The max commission rate that the validator can set (in range of [0;100_00] means [0-100%])\n  uint256 internal _maxCommissionRate;\n  /// @dev The min commission rate that the validator can set (in range of [0;100_00] means [0-100%])\n  uint256 internal _minCommissionRate;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] ______gap;\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function minValidatorStakingAmount() public view override returns (uint256) {\n    return _minValidatorStakingAmount;\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function getCommissionRateRange() external view override returns (uint256, uint256) {\n    return (_minCommissionRate, _maxCommissionRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function setMinValidatorStakingAmount(uint256 threshold) external override onlyAdmin {\n    _setMinValidatorStakingAmount(threshold);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function setCommissionRateRange(uint256 minRate, uint256 maxRate) external override onlyAdmin {\n    _setCommissionRateRange(minRate, maxRate);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function applyValidatorCandidate(\n    address candidateAdmin,\n    TConsensus consensusAddr,\n    address payable treasuryAddr,\n    uint256 commissionRate,\n    bytes calldata pubkey,\n    bytes calldata proofOfPossession\n  ) external payable override nonReentrant {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    if (commissionRate > _maxCommissionRate || commissionRate < _minCommissionRate) revert ErrInvalidCommissionRate();\n\n    uint256 amount = msg.value;\n    address payable poolAdmin = payable(msg.sender);\n    address poolId = TConsensus.unwrap(consensusAddr);\n\n    _applyValidatorCandidate({\n      poolAdmin: poolAdmin,\n      candidateAdmin: candidateAdmin,\n      poolId: poolId,\n      treasuryAddr: treasuryAddr,\n      pubkey: pubkey,\n      proofOfPossession: proofOfPossession,\n      commissionRate: commissionRate,\n      amount: amount\n    });\n\n    PoolDetail storage _pool = _poolDetail[poolId];\n    _pool.__shadowedPoolAdmin = poolAdmin;\n    _pool.pid = poolId;\n    _adminOfActivePoolMapping[poolAdmin] = poolId;\n\n    _stake(_poolDetail[poolId], poolAdmin, amount);\n    emit PoolApproved(poolId, poolAdmin);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestUpdateCommissionRate(\n    TConsensus consensusAddr,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  )\n    external\n    override\n    poolOfConsensusIsActive(consensusAddr)\n    onlyPoolAdmin(_poolDetail[__css2cid(consensusAddr)], msg.sender)\n  {\n    if (commissionRate > _maxCommissionRate || commissionRate < _minCommissionRate) revert ErrInvalidCommissionRate();\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execRequestUpdateCommissionRate(\n      __css2cid(consensusAddr),\n      effectiveDaysOnwards,\n      commissionRate\n    );\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function execDeprecatePools(\n    address[] calldata poolIds,\n    uint256 newPeriod\n  ) external override onlyContract(ContractType.VALIDATOR) {\n    if (poolIds.length == 0) {\n      return;\n    }\n\n    for (uint i = 0; i < poolIds.length; ) {\n      address poolId = poolIds[i];\n      PoolDetail storage _pool = _poolDetail[poolId];\n      // Deactivate the pool admin in the active mapping.\n      delete _adminOfActivePoolMapping[_pool.__shadowedPoolAdmin];\n\n      // Deduct and transfer the self staking amount to the pool admin.\n      uint256 deductingAmount = _pool.stakingAmount;\n      if (deductingAmount > 0) {\n        _deductStakingAmount(_pool, deductingAmount);\n        if (!_unsafeSendRONLimitGas(payable(_pool.__shadowedPoolAdmin), deductingAmount, DEFAULT_ADDITION_GAS)) {\n          emit StakingAmountTransferFailed(\n            _pool.pid,\n            _pool.__shadowedPoolAdmin,\n            deductingAmount,\n            address(this).balance\n          );\n        }\n      }\n\n      // Settle the unclaimed reward and transfer to the pool admin.\n      uint256 lastRewardAmount = _claimReward(poolId, _pool.__shadowedPoolAdmin, newPeriod);\n      if (lastRewardAmount > 0) {\n        _unsafeSendRONLimitGas(payable(_pool.__shadowedPoolAdmin), lastRewardAmount, DEFAULT_ADDITION_GAS);\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    emit PoolsDeprecated(poolIds);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function stake(\n    TConsensus consensusAddr\n  ) external payable override noEmptyValue poolOfConsensusIsActive(consensusAddr) {\n    address poolId = __css2cid(consensusAddr);\n    _stake(_poolDetail[poolId], msg.sender, msg.value);\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function unstake(\n    TConsensus consensusAddr,\n    uint256 amount\n  ) external override nonReentrant poolOfConsensusIsActive(consensusAddr) {\n    if (amount == 0) revert ErrUnstakeZeroAmount();\n    address requester = msg.sender;\n    address poolId = __css2cid(consensusAddr);\n    PoolDetail storage _pool = _poolDetail[poolId];\n    uint256 remainAmount = _pool.stakingAmount - amount;\n    if (remainAmount < _minValidatorStakingAmount) revert ErrStakingAmountLeft();\n\n    _unstake(_pool, requester, amount);\n    if (!_unsafeSendRONLimitGas(payable(requester), amount, DEFAULT_ADDITION_GAS)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestRenounce(\n    TConsensus consensusAddr\n  )\n    external\n    override\n    poolOfConsensusIsActive(consensusAddr)\n    onlyPoolAdmin(_poolDetail[__css2cid(consensusAddr)], msg.sender)\n  {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execRequestRenounceCandidate(\n      __css2cid(consensusAddr),\n      _waitingSecsToRevoke\n    );\n  }\n\n  /**\n   * @inheritdoc ICandidateStaking\n   */\n  function requestEmergencyExit(\n    TConsensus consensusAddr\n  )\n    external\n    override\n    poolOfConsensusIsActive(consensusAddr)\n    onlyPoolAdmin(_poolDetail[__css2cid(consensusAddr)], msg.sender)\n  {\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execRequestEmergencyExit(\n      __css2cid(consensusAddr),\n      _waitingSecsToRevoke\n    );\n  }\n\n  /**\n   * @dev See `ICandidateStaking-applyValidatorCandidate`\n   */\n  function _applyValidatorCandidate(\n    address payable poolAdmin,\n    address candidateAdmin,\n    address poolId,\n    address payable treasuryAddr,\n    bytes memory pubkey,\n    bytes memory proofOfPossession,\n    uint256 commissionRate,\n    uint256 amount\n  ) internal {\n    if (!_unsafeSendRONLimitGas(poolAdmin, 0, DEFAULT_ADDITION_GAS)) {\n      revert ErrCannotInitTransferRON(poolAdmin, \"pool admin\");\n    }\n    if (!_unsafeSendRONLimitGas(treasuryAddr, 0, DEFAULT_ADDITION_GAS)) {\n      revert ErrCannotInitTransferRON(treasuryAddr, \"treasury\");\n    }\n    if (amount < _minValidatorStakingAmount) revert ErrInsufficientStakingAmount();\n    if (poolAdmin != candidateAdmin || candidateAdmin != treasuryAddr) revert ErrThreeInteractionAddrsNotEqual();\n\n    {\n      address[] memory diffAddrs = new address[](3);\n      diffAddrs[0] = poolAdmin;\n      diffAddrs[1] = poolId;\n      if (AddressArrayUtils.hasDuplicate(diffAddrs)) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n    }\n\n    IRoninValidatorSet(getContract(ContractType.VALIDATOR)).execApplyValidatorCandidate({\n      candidateAdmin: candidateAdmin,\n      cid: poolId,\n      treasuryAddr: treasuryAddr,\n      commissionRate: commissionRate\n    });\n\n    IProfile profileContract = IProfile(getContract(ContractType.PROFILE));\n    profileContract.execApplyValidatorCandidate(candidateAdmin, poolId, treasuryAddr, pubkey, proofOfPossession);\n  }\n\n  /**\n   * @dev See `ICandidateStaking-stake`\n   */\n  function _stake(\n    PoolDetail storage _pool,\n    address requester,\n    uint256 amount\n  ) internal onlyPoolAdmin(_pool, requester) {\n    _pool.stakingAmount += amount;\n    _changeDelegatingAmount(_pool, requester, _pool.stakingAmount, _pool.stakingTotal + amount);\n    _pool.lastDelegatingTimestamp[requester] = block.timestamp;\n    emit Staked(_pool.pid, amount);\n  }\n\n  /**\n   * @dev See `ICandidateStaking-unstake`\n   */\n  function _unstake(\n    PoolDetail storage _pool,\n    address requester,\n    uint256 amount\n  ) internal onlyPoolAdmin(_pool, requester) {\n    if (amount > _pool.stakingAmount) revert ErrInsufficientStakingAmount();\n    if (_pool.lastDelegatingTimestamp[requester] + _cooldownSecsToUndelegate > block.timestamp) {\n      revert ErrUnstakeTooEarly();\n    }\n\n    _pool.stakingAmount -= amount;\n    _changeDelegatingAmount(_pool, requester, _pool.stakingAmount, _pool.stakingTotal - amount);\n    emit Unstaked(_pool.pid, amount);\n  }\n\n  /**\n   * @dev Deducts from staking amount of the validator `_consensusAddr` for `_amount`.\n   *\n   * Emits the event `Unstaked`.\n   *\n   * @return The actual deducted amount\n   */\n  function _deductStakingAmount(PoolDetail storage _pool, uint256 amount) internal virtual returns (uint256);\n\n  /**\n   * @dev Sets the minimum threshold for being a validator candidate.\n   *\n   * Emits the `MinValidatorStakingAmountUpdated` event.\n   *\n   */\n  function _setMinValidatorStakingAmount(uint256 threshold) internal {\n    _minValidatorStakingAmount = threshold;\n    emit MinValidatorStakingAmountUpdated(threshold);\n  }\n\n  /**\n   * @dev Sets the max commission rate that a candidate can set.\n   *\n   * Emits the `MaxCommissionRateUpdated` event.\n   *\n   */\n  function _setCommissionRateRange(uint256 minRate, uint256 maxRate) internal {\n    if (maxRate > _MAX_PERCENTAGE || minRate > maxRate) revert ErrInvalidCommissionRate();\n    _maxCommissionRate = maxRate;\n    _minCommissionRate = minRate;\n    emit CommissionRateRangeUpdated(minRate, maxRate);\n  }\n}\n"
    },
    "contracts/ronin/staking/DelegatorStaking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/staking/IDelegatorStaking.sol\";\nimport \"./BaseStaking.sol\";\n\nabstract contract DelegatorStaking is BaseStaking, IDelegatorStaking {\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function delegate(TConsensus consensusAddr) external payable noEmptyValue poolOfConsensusIsActive(consensusAddr) {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    _delegate(_poolDetail[__css2cid(consensusAddr)], msg.sender, msg.value);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function undelegate(TConsensus consensusAddr, uint256 amount) external nonReentrant {\n    address payable delegator = payable(msg.sender);\n    _undelegate(consensusAddr, _poolDetail[__css2cid(consensusAddr)], delegator, amount);\n    if (!_sendRON(delegator, amount)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function bulkUndelegate(TConsensus[] calldata consensusAddrs, uint256[] calldata amounts) external nonReentrant {\n    if (consensusAddrs.length == 0 || consensusAddrs.length != amounts.length) revert ErrInvalidArrays();\n\n    address payable delegator = payable(msg.sender);\n    uint256 total;\n\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    for (uint i = 0; i < poolIds.length; ) {\n      total += amounts[i];\n      _undelegate(consensusAddrs[i], _poolDetail[poolIds[i]], delegator, amounts[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    if (!_sendRON(delegator, total)) revert ErrCannotTransferRON();\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function redelegate(\n    TConsensus consensusAddrSrc,\n    TConsensus consensusAddrDst,\n    uint256 amount\n  ) external nonReentrant poolOfConsensusIsActive(consensusAddrDst) {\n    address delegator = msg.sender;\n    _undelegate(consensusAddrSrc, _poolDetail[__css2cid(consensusAddrSrc)], delegator, amount);\n    _delegate(_poolDetail[__css2cid(consensusAddrDst)], delegator, amount);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function claimRewards(\n    TConsensus[] calldata consensusAddrList\n  ) external override nonReentrant returns (uint256 amount) {\n    amount = _claimRewards(msg.sender, __css2cidBatch(consensusAddrList));\n    _transferRON(payable(msg.sender), amount);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function delegateRewards(\n    TConsensus[] calldata consensusAddrList,\n    TConsensus consensusAddrDst\n  ) external override nonReentrant poolOfConsensusIsActive(consensusAddrDst) returns (uint256 amount) {\n    if (isAdminOfActivePool(msg.sender)) revert ErrAdminOfAnyActivePoolForbidden(msg.sender);\n    address[] memory poolIds = __css2cidBatch(consensusAddrList);\n    address poolIdDst = __css2cid(consensusAddrDst);\n    return _delegateRewards(msg.sender, poolIds, poolIdDst);\n  }\n\n  /**\n   * @inheritdoc IDelegatorStaking\n   */\n  function getRewards(\n    address user,\n    TConsensus[] calldata consensusAddrs\n  ) external view returns (uint256[] memory rewards_) {\n    uint256 period = IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n    rewards_ = new uint256[](consensusAddrs.length);\n\n    address[] memory poolIds = __css2cidBatch(consensusAddrs);\n    for (uint256 i = 0; i < consensusAddrs.length; ) {\n      address poolId = poolIds[i];\n      rewards_[i] = _getReward(poolId, user, period, _getStakingAmount(poolId, user));\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Delegates from a validator address.\n   *\n   * Requirements:\n   * - The delegator is not the pool admin.\n   *\n   * Emits the `Delegated` event.\n   *\n   * Note: This function does not verify the `msg.value` with the amount.\n   *\n   */\n  function _delegate(\n    PoolDetail storage _pool,\n    address delegator,\n    uint256 amount\n  ) internal anyExceptPoolAdmin(_pool, delegator) {\n    _changeDelegatingAmount(_pool, delegator, _pool.delegatingAmount[delegator] + amount, _pool.stakingTotal + amount);\n    _pool.lastDelegatingTimestamp[delegator] = block.timestamp;\n    emit Delegated(delegator, _pool.pid, amount);\n  }\n\n  /**\n   * @dev Undelegates from a validator address.\n   *\n   * Requirements:\n   * - The delegator is not the pool admin.\n   * - The amount is larger than 0.\n   * - The delegating amount is larger than or equal to the undelegating amount.\n   *\n   * Emits the `Undelegated` event.\n   *\n   * Note: Consider transferring back the amount of RON after calling this function.\n   *\n   */\n  function _undelegate(\n    TConsensus consensusAddr,\n    PoolDetail storage _pool,\n    address delegator,\n    uint256 amount\n  ) private anyExceptPoolAdmin(_pool, delegator) {\n    if (amount == 0) revert ErrUndelegateZeroAmount();\n    if (_pool.delegatingAmount[delegator] < amount) revert ErrInsufficientDelegatingAmount();\n\n    IRoninValidatorSet validatorContract = IRoninValidatorSet(getContract(ContractType.VALIDATOR));\n    if (\n      validatorContract.isValidatorCandidate(consensusAddr) &&\n      validatorContract.getCandidateInfo(consensusAddr).revokingTimestamp == 0 && // if candidate is not on renunciation\n      _pool.lastDelegatingTimestamp[delegator] + _cooldownSecsToUndelegate >= block.timestamp // delegator is still in cooldown\n    ) revert ErrUndelegateTooEarly();\n\n    _changeDelegatingAmount(_pool, delegator, _pool.delegatingAmount[delegator] - amount, _pool.stakingTotal - amount);\n    emit Undelegated(delegator, _pool.pid, amount);\n  }\n\n  /**\n   * @dev Claims rewards from the pools `_poolAddrList`.\n   * Note: This function does not transfer reward to user.\n   */\n  function _claimRewards(address user, address[] memory poolIds) internal returns (uint256 amount) {\n    uint256 period = _currentPeriod();\n    for (uint256 i = 0; i < poolIds.length; ) {\n      amount += _claimReward(poolIds[i], user, period);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @dev Claims the rewards and delegates them to the consensus address.\n   */\n  function _delegateRewards(\n    address user,\n    address[] memory poolIds,\n    address poolIdDst\n  ) internal returns (uint256 amount) {\n    amount = _claimRewards(user, poolIds);\n    _delegate(_poolDetail[poolIdDst], user, amount);\n  }\n}\n"
    },
    "contracts/ronin/staking/RewardCalculation.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/staking/IRewardPool.sol\";\nimport \"../../libraries/Math.sol\";\nimport { TPoolId } from \"../../udvts/Types.sol\";\n\n/**\n * @title RewardCalculation contract\n * @dev This contract mainly contains the methods to calculate reward for staking contract.\n */\nabstract contract RewardCalculation is IRewardPool {\n  /// @dev Mapping from pool address => period number => accumulated rewards per share (one unit staking)\n  mapping(address => mapping(uint256 => PeriodWrapper)) private _accumulatedRps;\n  /// @dev Mapping from the pool address => user address => the reward info of the user\n  mapping(address => mapping(address => UserRewardFields)) private _userReward;\n  /// @dev Mapping from the pool address => reward pool fields\n  mapping(address => PoolFields) private _stakingPool;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  /**\n   * @inheritdoc IRewardPool\n   */\n  function getReward(TConsensus consensusAddr, address user) external view returns (uint256) {\n    address poolId = TConsensus.unwrap(consensusAddr);\n    return _getReward(poolId, user, _currentPeriod(), _getStakingAmount(poolId, user));\n  }\n\n  /**\n   * @dev See {IRewardPool-getStakingAmount}\n   */\n  function _getStakingAmount(address poolId, address user) internal view virtual returns (uint256);\n\n  /**\n   * @dev See {IRewardPool-getStakingTotal}\n   */\n  function _getStakingTotal(address poolId) internal view virtual returns (uint256);\n\n  /**\n   * @dev Returns the reward amount that user claimable.\n   */\n  function _getReward(\n    address poolId,\n    address user,\n    uint256 latestPeriod,\n    uint256 latestStakingAmount\n  ) internal view returns (uint256) {\n    UserRewardFields storage _reward = _userReward[poolId][user];\n\n    if (_reward.lastPeriod == latestPeriod) {\n      return _reward.debited;\n    }\n\n    uint256 aRps;\n    uint256 lastPeriodReward;\n    PoolFields storage _pool = _stakingPool[poolId];\n    PeriodWrapper storage _wrappedArps = _accumulatedRps[poolId][_reward.lastPeriod];\n\n    if (_wrappedArps.lastPeriod > 0) {\n      // Calculates the last period reward if the aRps at the period is set\n      aRps = _wrappedArps.inner;\n      lastPeriodReward = _reward.lowestAmount * (aRps - _reward.aRps);\n    } else {\n      // Fallbacks to the previous aRps in case the aRps is not set\n      aRps = _reward.aRps;\n    }\n\n    uint256 newPeriodsReward = latestStakingAmount * (_pool.aRps - aRps);\n    return _reward.debited + (lastPeriodReward + newPeriodsReward) / 1e18;\n  }\n\n  /**\n   * @dev Syncs the user reward.\n   *\n   * Emits the event `UserRewardUpdated` once the debit amount is updated.\n   * Emits the event `PoolSharesUpdated` once the pool share is updated.\n   *\n   * Note: The method should be called whenever the user's staking amount changes.\n   *\n   */\n  function _syncUserReward(address poolId, address user, uint256 newStakingAmount) internal {\n    uint256 period = _currentPeriod();\n    PoolFields storage _pool = _stakingPool[poolId];\n    uint256 lastShares = _pool.shares.inner;\n\n    // Updates the pool shares if it is outdated\n    if (_pool.shares.lastPeriod < period) {\n      _pool.shares = PeriodWrapper(_getStakingTotal(poolId), period);\n    }\n\n    UserRewardFields storage _reward = _userReward[poolId][user];\n    uint256 currentStakingAmount = _getStakingAmount(poolId, user);\n    uint256 debited = _getReward(poolId, user, period, currentStakingAmount);\n\n    if (_reward.debited != debited) {\n      _reward.debited = debited;\n      emit UserRewardUpdated(poolId, user, debited);\n    }\n\n    _syncMinStakingAmount(_pool, _reward, period, newStakingAmount, currentStakingAmount);\n    _reward.aRps = _pool.aRps;\n    _reward.lastPeriod = period;\n\n    if (_pool.shares.inner != lastShares) {\n      emit PoolSharesUpdated(period, poolId, _pool.shares.inner);\n    }\n  }\n\n  /**\n   * @dev Syncs the minimum staking amount of an user in the current period.\n   */\n  function _syncMinStakingAmount(\n    PoolFields storage _pool,\n    UserRewardFields storage _reward,\n    uint256 latestPeriod,\n    uint256 newStakingAmount,\n    uint256 currentStakingAmount\n  ) internal {\n    if (_reward.lastPeriod < latestPeriod) {\n      _reward.lowestAmount = currentStakingAmount;\n    }\n\n    uint256 lowestAmount = Math.min(_reward.lowestAmount, newStakingAmount);\n    uint256 diffAmount = _reward.lowestAmount - lowestAmount;\n    if (diffAmount > 0) {\n      _reward.lowestAmount = lowestAmount;\n      if (_pool.shares.inner < diffAmount) revert ErrInvalidPoolShare();\n      _pool.shares.inner -= diffAmount;\n    }\n  }\n\n  /**\n   * @dev Claims the settled reward for a specific user.\n   *\n   * @param lastPeriod Must be in two possible value: `_currentPeriod` in normal calculation, or\n   * `_currentPeriod + 1` in case of calculating the reward for revoked validators.\n   *\n   * Emits the `RewardClaimed` event and the `UserRewardUpdated` event.\n   *\n   * Note: This method should be called before transferring rewards for the user.\n   *\n   */\n  function _claimReward(address poolId, address user, uint256 lastPeriod) internal returns (uint256 amount) {\n    uint256 currentStakingAmount = _getStakingAmount(poolId, user);\n    amount = _getReward(poolId, user, lastPeriod, currentStakingAmount);\n    emit RewardClaimed(poolId, user, amount);\n\n    UserRewardFields storage _reward = _userReward[poolId][user];\n    _reward.debited = 0;\n    _syncMinStakingAmount(_stakingPool[poolId], _reward, lastPeriod, currentStakingAmount, currentStakingAmount);\n    _reward.lastPeriod = lastPeriod;\n    _reward.aRps = _stakingPool[poolId].aRps;\n    emit UserRewardUpdated(poolId, user, 0);\n  }\n\n  /**\n   * @dev Records the amount of rewards `_rewards` for the pools `poolIds`.\n   *\n   * Emits the event `PoolsUpdated` once the contract recorded the rewards successfully.\n   * Emits the event `PoolsUpdateFailed` once the input array lengths are not equal.\n   * Emits the event `PoolUpdateConflicted` when the pool is already updated in the period.\n   *\n   * Note: This method should be called once at the period ending.\n   *\n   */\n  function _recordRewards(address[] memory poolIds, uint256[] calldata rewards, uint256 period) internal {\n    if (poolIds.length != rewards.length) {\n      emit PoolsUpdateFailed(period, poolIds, rewards);\n      return;\n    }\n\n    uint256 rps;\n    uint256 count;\n    address poolId;\n    uint256 stakingTotal;\n    uint256[] memory aRps = new uint256[](poolIds.length);\n    uint256[] memory shares = new uint256[](poolIds.length);\n    address[] memory conflicted = new address[](poolIds.length);\n\n    for (uint i = 0; i < poolIds.length; i++) {\n      poolId = poolIds[i];\n      PoolFields storage _pool = _stakingPool[poolId];\n      stakingTotal = _getStakingTotal(poolId);\n\n      if (_accumulatedRps[poolId][period].lastPeriod == period) {\n        unchecked {\n          conflicted[count++] = poolId;\n        }\n        continue;\n      }\n\n      // Updates the pool shares if it is outdated\n      if (_pool.shares.lastPeriod < period) {\n        _pool.shares = PeriodWrapper(stakingTotal, period);\n      }\n\n      // The rps is 0 if no one stakes for the pool\n      rps = _pool.shares.inner == 0 ? 0 : (rewards[i] * 1e18) / _pool.shares.inner;\n      aRps[i - count] = _pool.aRps += rps;\n      _accumulatedRps[poolId][period] = PeriodWrapper(_pool.aRps, period);\n      _pool.shares.inner = stakingTotal;\n      shares[i - count] = _pool.shares.inner;\n      poolIds[i - count] = poolId;\n    }\n\n    if (count > 0) {\n      assembly {\n        mstore(conflicted, count)\n        mstore(poolIds, sub(mload(poolIds), count))\n      }\n      emit PoolsUpdateConflicted(period, conflicted);\n    }\n\n    if (poolIds.length > 0) {\n      emit PoolsUpdated(period, poolIds, aRps, shares);\n    }\n  }\n\n  /**\n   * @dev Returns the current period.\n   */\n  function _currentPeriod() internal view virtual returns (uint256);\n}\n"
    },
    "contracts/ronin/staking/Staking.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../libraries/Math.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./StakingCallback.sol\";\n\ncontract Staking is IStaking, StakingCallback, Initializable {\n  constructor() {\n    _disableInitializers();\n  }\n\n  receive() external payable onlyContract(ContractType.VALIDATOR) {}\n\n  fallback() external payable onlyContract(ContractType.VALIDATOR) {}\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __validatorContract,\n    uint256 __minValidatorStakingAmount,\n    uint256 __maxCommissionRate,\n    uint256 __cooldownSecsToUndelegate,\n    uint256 __waitingSecsToRevoke\n  ) external initializer {\n    _setContract(ContractType.VALIDATOR, __validatorContract);\n    _setMinValidatorStakingAmount(__minValidatorStakingAmount);\n    _setCommissionRateRange(0, __maxCommissionRate);\n    _setCooldownSecsToUndelegate(__cooldownSecsToUndelegate);\n    _setWaitingSecsToRevoke(__waitingSecsToRevoke);\n  }\n\n  /**\n   * @dev Initializes the contract storage V2.\n   */\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.VALIDATOR, ______deprecatedValidator);\n    delete ______deprecatedValidator;\n  }\n\n  /**\n   * @dev Initializes the contract storage V3.\n   */\n  function initializeV3(address __profileContract) external reinitializer(3) {\n    _setContract(ContractType.PROFILE, __profileContract);\n  }\n\n  /**\n   * @inheritdoc IStaking\n   */\n  function execRecordRewards(\n    address[] calldata poolIds,\n    uint256[] calldata rewards,\n    uint256 period\n  ) external payable override onlyContract(ContractType.VALIDATOR) {\n    _recordRewards(poolIds, rewards, period);\n  }\n\n  /**\n   * @inheritdoc IStaking\n   */\n  function execDeductStakingAmount(\n    address poolId,\n    uint256 amount\n  ) external override onlyContract(ContractType.VALIDATOR) returns (uint256 actualDeductingAmount_) {\n    actualDeductingAmount_ = _deductStakingAmount(_poolDetail[poolId], amount);\n    address payable validatorContractAddr = payable(msg.sender);\n    if (!_unsafeSendRON(validatorContractAddr, actualDeductingAmount_)) {\n      emit StakingAmountDeductFailed(poolId, validatorContractAddr, actualDeductingAmount_, address(this).balance);\n    }\n  }\n\n  /**\n   * @inheritdoc RewardCalculation\n   */\n  function _currentPeriod() internal view virtual override returns (uint256) {\n    return IRoninValidatorSet(getContract(ContractType.VALIDATOR)).currentPeriod();\n  }\n\n  /**\n   * @inheritdoc CandidateStaking\n   */\n  function _deductStakingAmount(\n    PoolDetail storage _pool,\n    uint256 amount\n  ) internal override returns (uint256 actualDeductingAmount_) {\n    actualDeductingAmount_ = Math.min(_pool.stakingAmount, amount);\n\n    _pool.stakingAmount -= actualDeductingAmount_;\n    _changeDelegatingAmount(\n      _pool,\n      _pool.__shadowedPoolAdmin,\n      _pool.stakingAmount,\n      Math.subNonNegative(_pool.stakingTotal, actualDeductingAmount_)\n    );\n    emit Unstaked(_pool.pid, actualDeductingAmount_);\n  }\n}\n"
    },
    "contracts/ronin/staking/StakingCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\nimport \"../../interfaces/IProfile.sol\";\nimport \"../../interfaces/staking/IStakingCallback.sol\";\nimport \"./CandidateStaking.sol\";\nimport \"./DelegatorStaking.sol\";\n\npragma solidity ^0.8.9;\n\nabstract contract StakingCallback is CandidateStaking, DelegatorStaking, IStakingCallback {\n  /**\n   * @dev Requirements:\n   * - Only Profile contract can call this method.\n   */\n  function execChangeAdminAddress(\n    address poolAddr,\n    address newAdminAddr\n  ) external override onlyContract(ContractType.PROFILE) {\n    PoolDetail storage _pool = _poolDetail[poolAddr];\n\n    _adminOfActivePoolMapping[_pool.__shadowedPoolAdmin] = address(0);\n    _pool.__shadowedPoolAdmin = newAdminAddr;\n    _adminOfActivePoolMapping[newAdminAddr] = poolAddr;\n  }\n}\n"
    },
    "contracts/ronin/validator/CandidateManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../extensions/consumers/PercentageConsumer.sol\";\nimport \"../../interfaces/validator/ICandidateManager.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport { HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\n\nabstract contract CandidateManager is\n  ICandidateManager,\n  PercentageConsumer,\n  GlobalConfigConsumer,\n  HasContracts,\n  HasStakingDeprecated\n{\n  /// @dev Maximum number of validator candidate\n  uint256 private _maxValidatorCandidate;\n\n  /// @dev The array of candidate ids\n  address[] internal _candidateIds;\n  /// @dev Mapping from candidate id => bitwise negation of validator index in `_candidates`\n  mapping(address => uint256) internal _candidateIndex;\n  /// @dev Mapping from candidate id => their info\n  mapping(address => ValidatorCandidate) internal _candidateInfo;\n\n  /**\n   * @dev The minimum offset in day from current date to the effective date of a new commission schedule.\n   * Value of 1 means the change gets affected at the beginning of the following day.\n   **/\n  uint256 internal _minEffectiveDaysOnwards;\n  /// @dev Mapping from candidate consensus id => schedule commission change.\n  mapping(address => CommissionSchedule) internal _candidateCommissionChangeSchedule;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function maxValidatorCandidate() public view override returns (uint256) {\n    return _maxValidatorCandidate;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function minEffectiveDaysOnward() external view override returns (uint256) {\n    return _minEffectiveDaysOnwards;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMaxValidatorCandidate(uint256 _number) external override onlyAdmin {\n    _setMaxValidatorCandidate(_number);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function setMinEffectiveDaysOnwards(uint256 _numOfDays) external override onlyAdmin {\n    _setMinEffectiveDaysOnwards(_numOfDays);\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isValidatorCandidate(TConsensus consensus) external view override returns (bool) {\n    return _isValidatorCandidateById(__css2cid(consensus));\n  }\n\n  function _isValidatorCandidateById(address cid) internal view returns (bool) {\n    return _candidateIndex[cid] != 0;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfos() external view override returns (ValidatorCandidate[] memory list) {\n    list = new ValidatorCandidate[](_candidateIds.length);\n    for (uint i; i < list.length; ) {\n      list[i] = _candidateInfo[_candidateIds[i]];\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCandidateInfo(TConsensus consensus) external view override returns (ValidatorCandidate memory) {\n    address validatorId = __css2cid(consensus);\n    if (!_isValidatorCandidateById(validatorId)) revert ErrNonExistentCandidate();\n    return _candidateInfo[validatorId];\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getValidatorCandidates() external view override returns (TConsensus[] memory) {\n    return __cid2cssBatch(getValidatorCandidateIds());\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getValidatorCandidateIds() public view override returns (address[] memory) {\n    return _candidateIds;\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function getCommissionChangeSchedule(\n    TConsensus consensus\n  ) external view override returns (CommissionSchedule memory) {\n    return _candidateCommissionChangeSchedule[__css2cid(consensus)];\n  }\n\n  /**\n   * @dev Removes unsastisfied candidates, the ones who have insufficient minimum candidate staking amount,\n   * or the ones who requested to renounce their candidate role.\n   *\n   * Emits the event `CandidatesRevoked` when a candidate is revoked.\n   *\n   */\n  function _syncCandidateSet(uint256 _nextPeriod) internal returns (address[] memory _unsatisfiedCandidates) {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    uint256 _waitingSecsToRevoke = _staking.waitingSecsToRevoke();\n    uint256 _minStakingAmount = _staking.minValidatorStakingAmount();\n    uint256[] memory _selfStakings = _staking.getManySelfStakingsById(_candidateIds);\n\n    uint256 _length = _candidateIds.length;\n    uint256 _unsatisfiedCount;\n    _unsatisfiedCandidates = new address[](_length);\n\n    {\n      uint256 _i;\n      address cid;\n      ValidatorCandidate storage _info;\n      while (_i < _length) {\n        cid = _candidateIds[_i];\n        _info = _candidateInfo[cid];\n\n        // Checks for under-balance status of candidates\n        bool _hasTopupDeadline = _info.topupDeadline != 0;\n        if (_selfStakings[_i] < _minStakingAmount) {\n          // Updates deadline on the first time unsatisfied the staking amount condition\n          if (!_hasTopupDeadline) {\n            uint256 _topupDeadline = block.timestamp + _waitingSecsToRevoke;\n            _info.topupDeadline = _topupDeadline;\n            emit CandidateTopupDeadlineUpdated(cid, _topupDeadline);\n          }\n        } else if (_hasTopupDeadline) {\n          // Removes the deadline if the staking amount condition is satisfied\n          delete _info.topupDeadline;\n          emit CandidateTopupDeadlineUpdated(cid, 0);\n        }\n\n        // Removes unsatisfied candidates\n        bool _revokingActivated = (_info.revokingTimestamp != 0 && _info.revokingTimestamp <= block.timestamp) ||\n          _emergencyExitLockedFundReleased(cid);\n        bool _topupDeadlineMissed = _info.topupDeadline != 0 && _info.topupDeadline <= block.timestamp;\n        if (_revokingActivated || _topupDeadlineMissed) {\n          _selfStakings[_i] = _selfStakings[--_length];\n          unchecked {\n            _unsatisfiedCandidates[_unsatisfiedCount++] = cid;\n          }\n          _removeCandidate(cid);\n          continue;\n        }\n\n        // Checks for schedule of commission change and updates commission rate\n        uint256 _scheduleTimestamp = _candidateCommissionChangeSchedule[cid].effectiveTimestamp;\n        if (_scheduleTimestamp != 0 && _scheduleTimestamp <= block.timestamp) {\n          uint256 _commisionRate = _candidateCommissionChangeSchedule[cid].commissionRate;\n          delete _candidateCommissionChangeSchedule[cid];\n          _info.commissionRate = _commisionRate;\n          emit CommissionRateUpdated(cid, _commisionRate);\n        }\n\n        unchecked {\n          _i++;\n        }\n      }\n    }\n\n    assembly {\n      mstore(_unsatisfiedCandidates, _unsatisfiedCount)\n    }\n\n    if (_unsatisfiedCount > 0) {\n      emit CandidatesRevoked(_unsatisfiedCandidates);\n      _staking.execDeprecatePools(_unsatisfiedCandidates, _nextPeriod);\n    }\n  }\n\n  /**\n   * @inheritdoc ICandidateManager\n   */\n  function isCandidateAdmin(TConsensus consensusAddr, address admin) external view override returns (bool) {\n    return _isCandidateAdminById(__css2cid(consensusAddr), admin);\n  }\n\n  function _isCandidateAdminById(address candidateId, address admin) internal view returns (bool) {\n    return _candidateInfo[candidateId].__shadowedAdmin == admin;\n  }\n\n  /**\n   * @dev Sets the maximum number of validator candidate.\n   *\n   * Emits the `MaxValidatorCandidateUpdated` event.\n   *\n   */\n  function _setMaxValidatorCandidate(uint256 _threshold) internal {\n    _maxValidatorCandidate = _threshold;\n    emit MaxValidatorCandidateUpdated(_threshold);\n  }\n\n  /**\n   * @dev Sets the minimum number of days onwards to the effective date of commission rate change.\n   *\n   * Emits the `MinEffectiveDaysOnwardsUpdated` event.\n   *\n   */\n  function _setMinEffectiveDaysOnwards(uint256 _numOfDays) internal {\n    if (_numOfDays < 1) revert ErrInvalidMinEffectiveDaysOnwards();\n    _minEffectiveDaysOnwards = _numOfDays;\n    emit MinEffectiveDaysOnwardsUpdated(_numOfDays);\n  }\n\n  /**\n   * @dev Removes the candidate.\n   */\n  function _removeCandidate(address _addr) internal virtual {\n    uint256 idx = _candidateIndex[_addr];\n    if (idx == 0) {\n      return;\n    }\n\n    delete _candidateInfo[_addr];\n    delete _candidateIndex[_addr];\n    delete _candidateCommissionChangeSchedule[_addr];\n\n    address lastCid = _candidateIds[_candidateIds.length - 1];\n    if (lastCid != _addr) {\n      _candidateIndex[lastCid] = idx;\n      _candidateIds[~idx] = lastCid;\n    }\n\n    _candidateIds.pop();\n  }\n\n  /**\n   * @dev Sets timestamp to revoke a candidate.\n   */\n  function _setRevokingTimestamp(ValidatorCandidate storage _candidate, uint256 timestamp) internal {\n    address cid = __css2cid(_candidate.__shadowedConsensus);\n    if (!_isValidatorCandidateById(cid)) revert ErrNonExistentCandidate();\n    _candidate.revokingTimestamp = timestamp;\n    emit CandidateRevokingTimestampUpdated(cid, timestamp);\n  }\n\n  /**\n   * @dev Returns a flag indicating whether the fund is unlocked.\n   */\n  function _emergencyExitLockedFundReleased(address _consensusAddr) internal virtual returns (bool);\n\n  /**\n   * @dev Returns whether the validator id is a trusted org or not.\n   */\n  function _isTrustedOrg(address validatorId) internal virtual returns (bool);\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n\n  /// @dev See {RoninValidatorSet-__cid2cssBatch}\n  function __cid2cssBatch(address[] memory cids) internal view virtual returns (TConsensus[] memory);\n}\n"
    },
    "contracts/ronin/validator/CandidateManagerCallback.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../interfaces/validator/ICandidateManagerCallback.sol\";\nimport \"./CandidateManager.sol\";\n\nabstract contract CandidateManagerCallback is ICandidateManagerCallback, CandidateManager {\n  //                                             //\n  // ----------- Staking's Callbacks ----------- //\n  //                                             //\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execApplyValidatorCandidate(\n    address candidateAdmin,\n    address cid,\n    address payable treasuryAddr,\n    uint256 commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    uint256 length = _candidateIds.length;\n    if (length >= maxValidatorCandidate()) revert ErrExceedsMaxNumberOfCandidate();\n    if (_isValidatorCandidateById(cid)) revert ErrExistentCandidate();\n    if (commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n\n    for (uint i; i < length; ) {\n      ValidatorCandidate storage existentInfo = _candidateInfo[_candidateIds[i]];\n      if (candidateAdmin == existentInfo.__shadowedAdmin) revert ErrExistentCandidateAdmin(candidateAdmin);\n      if (treasuryAddr == existentInfo.__shadowedTreasury) revert ErrExistentTreasury(treasuryAddr);\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    _candidateIndex[cid] = ~length;\n    _candidateIds.push(cid);\n\n    ValidatorCandidate storage _info = _candidateInfo[cid];\n    _info.__shadowedAdmin = candidateAdmin;\n    _info.__shadowedConsensus = TConsensus.wrap(cid);\n    _info.__shadowedTreasury = treasuryAddr;\n    _info.commissionRate = commissionRate;\n    emit CandidateGranted(cid, treasuryAddr, candidateAdmin);\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execRequestRenounceCandidate(\n    address cid,\n    uint256 secsLeft\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_isTrustedOrg(cid)) revert ErrTrustedOrgCannotRenounce();\n\n    ValidatorCandidate storage _info = _candidateInfo[cid];\n    if (_info.revokingTimestamp != 0) revert ErrAlreadyRequestedRevokingCandidate();\n    _setRevokingTimestamp(_info, block.timestamp + secsLeft);\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execRequestUpdateCommissionRate(\n    address cid,\n    uint256 effectiveDaysOnwards,\n    uint256 commissionRate\n  ) external override onlyContract(ContractType.STAKING) {\n    if (_candidateCommissionChangeSchedule[cid].effectiveTimestamp != 0) {\n      revert ErrAlreadyRequestedUpdatingCommissionRate();\n    }\n    if (commissionRate > _MAX_PERCENTAGE) revert ErrInvalidCommissionRate();\n    if (effectiveDaysOnwards < _minEffectiveDaysOnwards) revert ErrInvalidEffectiveDaysOnwards();\n\n    CommissionSchedule storage _schedule = _candidateCommissionChangeSchedule[cid];\n    uint256 effectiveTimestamp = ((block.timestamp / PERIOD_DURATION) + effectiveDaysOnwards) * PERIOD_DURATION;\n    _schedule.effectiveTimestamp = effectiveTimestamp;\n    _schedule.commissionRate = commissionRate;\n\n    emit CommissionRateUpdateScheduled(cid, effectiveTimestamp, commissionRate);\n  }\n\n  //                                             //\n  // ----------- Profile's Callbacks ----------- //\n  //                                             //\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execChangeConsensusAddress(\n    address cid,\n    TConsensus newConsensusAddr\n  ) external override onlyContract(ContractType.PROFILE) {\n    _candidateInfo[cid].__shadowedConsensus = newConsensusAddr;\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execChangeAdminAddress(address cid, address newAdmin) external onlyContract(ContractType.PROFILE) {\n    _candidateInfo[cid].__shadowedAdmin = newAdmin;\n  }\n\n  /**\n   * @inheritdoc ICandidateManagerCallback\n   */\n  function execChangeTreasuryAddress(\n    address cid,\n    address payable newTreasury\n  ) external onlyContract(ContractType.PROFILE) {\n    _candidateInfo[cid].__shadowedTreasury = newTreasury;\n  }\n}\n"
    },
    "contracts/ronin/validator/CoinbaseExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IProfile.sol\";\nimport \"../../interfaces/IStakingVesting.sol\";\nimport \"../../interfaces/IMaintenance.sol\";\nimport \"../../interfaces/IRoninTrustedOrganization.sol\";\nimport \"../../interfaces/IFastFinalityTracking.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../interfaces/slash-indicator/ISlashIndicator.sol\";\nimport \"../../interfaces/validator/ICoinbaseExecution.sol\";\nimport \"../../libraries/EnumFlags.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasStakingVestingDeprecated, HasBridgeTrackingDeprecated, HasMaintenanceDeprecated, HasSlashIndicatorDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"../../precompile-usages/PCUSortValidators.sol\";\nimport \"../../precompile-usages/PCUPickValidatorSet.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport { EmergencyExit } from \"./EmergencyExit.sol\";\nimport { TPoolId } from \"../../udvts/Types.sol\";\nimport { ErrCallerMustBeCoinbase } from \"../../utils/CommonErrors.sol\";\n\nabstract contract CoinbaseExecution is\n  ICoinbaseExecution,\n  RONTransferHelper,\n  PCUSortValidators,\n  PCUPickValidatorSet,\n  HasContracts,\n  HasStakingVestingDeprecated,\n  HasBridgeTrackingDeprecated,\n  HasMaintenanceDeprecated,\n  HasSlashIndicatorDeprecated,\n  EmergencyExit\n{\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  modifier onlyCoinbase() {\n    _requireCoinbase();\n    _;\n  }\n\n  modifier whenEpochEnding() {\n    if (!epochEndingAt(block.number)) revert ErrAtEndOfEpochOnly();\n    _;\n  }\n\n  modifier oncePerEpoch() {\n    if (epochOf(_lastUpdatedBlock) >= epochOf(block.number)) revert ErrAlreadyWrappedEpoch();\n    _lastUpdatedBlock = block.number;\n    _;\n  }\n\n  function _requireCoinbase() private view {\n    if (msg.sender != block.coinbase) revert ErrCallerMustBeCoinbase();\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function submitBlockReward() external payable override onlyCoinbase {\n    address id = __css2cid(TConsensus.wrap(msg.sender));\n\n    bool requestForBlockProducer = _isBlockProducerById(id) &&\n      !_isJailedById(id) &&\n      !_miningRewardDeprecatedById(id, currentPeriod());\n\n    (, uint256 blockProducerBonus, , uint256 fastFinalityRewardPercentage) = IStakingVesting(\n      getContract(ContractType.STAKING_VESTING)\n    ).requestBonus({ forBlockProducer: requestForBlockProducer, forBridgeOperator: false });\n\n    // Deprecates reward for non-validator or slashed validator\n    if (!requestForBlockProducer) {\n      _totalDeprecatedReward += msg.value;\n      emit BlockRewardDeprecated(id, msg.value, BlockRewardDeprecatedType.UNAVAILABILITY);\n      return;\n    }\n\n    emit BlockRewardSubmitted(id, msg.value, blockProducerBonus);\n\n    uint256 period = currentPeriod();\n    uint256 reward = msg.value + blockProducerBonus;\n    uint256 rewardFastFinality = (reward * fastFinalityRewardPercentage) / _MAX_PERCENTAGE; // reward for fast finality\n    uint256 rewardProducingBlock = reward - rewardFastFinality; // reward for producing blocks\n    uint256 cutOffReward;\n\n    // Add fast finality reward to total reward for current epoch, then split it later in the {wrapUpEpoch} method.\n    _totalFastFinalityReward += rewardFastFinality;\n\n    if (_miningRewardBailoutCutOffAtPeriod[msg.sender][period]) {\n      (, , , uint256 cutOffPercentage) = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR))\n        .getCreditScoreConfigs();\n      cutOffReward = (rewardProducingBlock * cutOffPercentage) / _MAX_PERCENTAGE;\n      _totalDeprecatedReward += cutOffReward;\n      emit BlockRewardDeprecated(id, cutOffReward, BlockRewardDeprecatedType.AFTER_BAILOUT);\n    }\n\n    rewardProducingBlock -= cutOffReward;\n    (uint256 minRate, uint256 maxRate) = IStaking(getContract(ContractType.STAKING)).getCommissionRateRange();\n    uint256 rate = Math.max(Math.min(_candidateInfo[id].commissionRate, maxRate), minRate);\n    uint256 miningAmount = (rate * rewardProducingBlock) / _MAX_PERCENTAGE;\n    _miningReward[id] += miningAmount;\n    _delegatingReward[id] += (rewardProducingBlock - miningAmount);\n  }\n\n  /**\n   * @inheritdoc ICoinbaseExecution\n   */\n  function wrapUpEpoch() external payable virtual override onlyCoinbase whenEpochEnding oncePerEpoch {\n    uint256 newPeriod = _computePeriod(block.timestamp);\n    bool periodEnding = _isPeriodEnding(newPeriod);\n\n    address[] memory currValidatorIds = getValidatorIds();\n    address[] memory revokedCandidateIds;\n    uint256 epoch = epochOf(block.number);\n    uint256 nextEpoch = epoch + 1;\n    uint256 lastPeriod = currentPeriod();\n\n    _syncFastFinalityReward(epoch, currValidatorIds);\n\n    if (periodEnding) {\n      (\n        uint256 totalDelegatingReward,\n        uint256[] memory delegatingRewards\n      ) = _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(lastPeriod, currValidatorIds);\n      _settleAndTransferDelegatingRewards(lastPeriod, currValidatorIds, totalDelegatingReward, delegatingRewards);\n      _tryRecycleLockedFundsFromEmergencyExits();\n      _recycleDeprecatedRewards();\n\n      ISlashIndicator slashIndicatorContract = ISlashIndicator(getContract(ContractType.SLASH_INDICATOR));\n      slashIndicatorContract.execUpdateCreditScores(currValidatorIds, lastPeriod);\n      (currValidatorIds, revokedCandidateIds) = _syncValidatorSet(newPeriod);\n      if (revokedCandidateIds.length > 0) {\n        slashIndicatorContract.execResetCreditScores(revokedCandidateIds);\n      }\n      _currentPeriodStartAtBlock = block.number + 1;\n    }\n    _revampRoles(newPeriod, nextEpoch, currValidatorIds);\n    emit WrappedUpEpoch(lastPeriod, epoch, periodEnding);\n    _periodOf[nextEpoch] = newPeriod;\n    _lastUpdatedPeriod = newPeriod;\n  }\n\n  /**\n   * @dev This method calculate and update reward of each `validators` accordingly their fast finality voting performance\n   * in the `epoch`. The leftover reward is added to the {_totalDeprecatedReward} and is recycled later to the\n   * {StakingVesting} contract.\n   *\n   * Requirements:\n   * - This method is only called once each epoch.\n   */\n  function _syncFastFinalityReward(uint256 epoch, address[] memory validatorIds) private {\n    uint256[] memory voteCounts = IFastFinalityTracking(getContract(ContractType.FAST_FINALITY_TRACKING))\n      .getManyFinalityVoteCounts(epoch, validatorIds);\n    uint256 divisor = _numberOfBlocksInEpoch * validatorIds.length;\n    uint256 iReward;\n    uint256 totalReward = _totalFastFinalityReward;\n    uint256 totalDispensedReward = 0;\n\n    for (uint i; i < validatorIds.length; ) {\n      iReward = (totalReward * voteCounts[i]) / divisor;\n      _fastFinalityReward[validatorIds[i]] += iReward;\n      totalDispensedReward += iReward;\n      unchecked {\n        ++i;\n      }\n    }\n\n    _totalDeprecatedReward += (totalReward - totalDispensedReward);\n    delete _totalFastFinalityReward;\n  }\n\n  /**\n   * @dev This loops over all current validators to:\n   * - Update delegating reward for and calculate total delegating rewards to be sent to the staking contract,\n   * - Distribute the reward of block producers and bridge operators to their treasury addresses,\n   * - Update the total deprecated reward if the two previous conditions do not satisfy.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeRewardToTreasuriesAndCalculateTotalDelegatingReward(\n    uint256 lastPeriod,\n    address[] memory currValidatorIds\n  ) private returns (uint256 totalDelegatingReward, uint256[] memory delegatingRewards) {\n    address vId; // validator id\n    address payable treasury;\n    delegatingRewards = new uint256[](currValidatorIds.length);\n\n    for (uint _i; _i < currValidatorIds.length; ) {\n      vId = currValidatorIds[_i];\n      treasury = _candidateInfo[vId].__shadowedTreasury;\n\n      if (!_isJailedById(vId) && !_miningRewardDeprecatedById(vId, lastPeriod)) {\n        totalDelegatingReward += _delegatingReward[vId];\n        delegatingRewards[_i] = _delegatingReward[vId];\n        _distributeMiningReward(vId, treasury);\n        _distributeFastFinalityReward(vId, treasury);\n      } else {\n        _totalDeprecatedReward += _miningReward[vId] + _delegatingReward[vId] + _fastFinalityReward[vId];\n      }\n\n      delete _delegatingReward[vId];\n      delete _miningReward[vId];\n      delete _fastFinalityReward[vId];\n\n      unchecked {\n        ++_i;\n      }\n    }\n  }\n\n  /**\n   * @dev Distributes bonus of staking vesting and mining fee for the block producer.\n   *\n   * Emits the `MiningRewardDistributed` once the reward is distributed successfully.\n   * Emits the `MiningRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _distributeMiningReward(address cid, address payable treasury) private {\n    uint256 amount = _miningReward[cid];\n    if (amount > 0) {\n      if (_unsafeSendRONLimitGas(treasury, amount, DEFAULT_ADDITION_GAS)) {\n        emit MiningRewardDistributed(cid, treasury, amount);\n        return;\n      }\n\n      emit MiningRewardDistributionFailed(cid, treasury, amount, address(this).balance);\n    }\n  }\n\n  function _distributeFastFinalityReward(address cid, address payable treasury) private {\n    uint256 amount = _fastFinalityReward[cid];\n    if (amount > 0) {\n      if (_unsafeSendRONLimitGas(treasury, amount, DEFAULT_ADDITION_GAS)) {\n        emit FastFinalityRewardDistributed(cid, treasury, amount);\n        return;\n      }\n\n      emit FastFinalityRewardDistributionFailed(cid, treasury, amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Helper function to settle rewards for delegators of `currValidatorIds` at the end of each period,\n   * then transfer the rewards from this contract to the staking contract, in order to finalize a period.\n   *\n   * Emits the `StakingRewardDistributed` once the reward is distributed successfully.\n   * Emits the `StakingRewardDistributionFailed` once the contract fails to distribute reward.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _settleAndTransferDelegatingRewards(\n    uint256 period,\n    address[] memory currValidatorIds,\n    uint256 totalDelegatingReward,\n    uint256[] memory delegatingRewards\n  ) private {\n    IStaking _staking = IStaking(getContract(ContractType.STAKING));\n    if (totalDelegatingReward > 0) {\n      if (_unsafeSendRON(payable(address(_staking)), totalDelegatingReward)) {\n        _staking.execRecordRewards(currValidatorIds, delegatingRewards, period);\n        emit StakingRewardDistributed(totalDelegatingReward, currValidatorIds, delegatingRewards);\n        return;\n      }\n\n      emit StakingRewardDistributionFailed(\n        totalDelegatingReward,\n        currValidatorIds,\n        delegatingRewards,\n        address(this).balance\n      );\n    }\n  }\n\n  /**\n   * @dev Transfer the deprecated rewards e.g. the rewards that get deprecated when validator is slashed/maintained,\n   * to the staking vesting contract\n   *\n   * Note: This method should be called once in the end of each period.\n   */\n  function _recycleDeprecatedRewards() private {\n    uint256 withdrawAmount = _totalDeprecatedReward;\n\n    if (withdrawAmount != 0) {\n      address withdrawTarget = getContract(ContractType.STAKING_VESTING);\n\n      delete _totalDeprecatedReward;\n\n      (bool _success, ) = withdrawTarget.call{ value: withdrawAmount }(\n        abi.encodeWithSelector(IStakingVesting.receiveRON.selector)\n      );\n\n      if (_success) {\n        emit DeprecatedRewardRecycled(withdrawTarget, withdrawAmount);\n      } else {\n        emit DeprecatedRewardRecycleFailed(withdrawTarget, withdrawAmount, address(this).balance);\n      }\n    }\n  }\n\n  /**\n   * @dev Updates the validator set based on the validator candidates from the Staking contract.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _syncValidatorSet(\n    uint256 newPeriod\n  ) private returns (address[] memory newValidatorIds, address[] memory unsatisfiedCandidates) {\n    unsatisfiedCandidates = _syncCandidateSet(newPeriod);\n    uint256[] memory weights = IStaking(getContract(ContractType.STAKING)).getManyStakingTotalsById(_candidateIds);\n    uint256[] memory trustedWeights = IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION))\n      .getConsensusWeightsById(_candidateIds);\n    uint256 newValidatorCount;\n    (newValidatorIds, newValidatorCount) = _pcPickValidatorSet(\n      _candidateIds,\n      weights,\n      trustedWeights,\n      _maxValidatorNumber,\n      _maxPrioritizedValidatorNumber\n    );\n    _setNewValidatorSet(newValidatorIds, newValidatorCount, newPeriod);\n  }\n\n  /**\n   * @dev Private helper function helps writing the new validator set into the contract storage.\n   *\n   * Emits the `ValidatorSetUpdated` event.\n   *\n   * Note: This method should be called once in the end of each period.\n   *\n   */\n  function _setNewValidatorSet(\n    address[] memory _newValidators,\n    uint256 _newValidatorCount,\n    uint256 _newPeriod\n  ) private {\n    // Remove exceeding validators in the current set\n    for (uint256 _i = _newValidatorCount; _i < _validatorCount; ) {\n      delete _validatorMap[_validatorIds[_i]];\n      delete _validatorIds[_i];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Remove flag for all validator in the current set\n    for (uint _i; _i < _newValidatorCount; ) {\n      delete _validatorMap[_validatorIds[_i]];\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    // Update new validator set and set flag correspondingly.\n    for (uint256 _i; _i < _newValidatorCount; ) {\n      address _newValidator = _newValidators[_i];\n      _validatorMap[_newValidator] = EnumFlags.ValidatorFlag.Both;\n      _validatorIds[_i] = _newValidator;\n\n      unchecked {\n        ++_i;\n      }\n    }\n\n    _validatorCount = _newValidatorCount;\n    emit ValidatorSetUpdated(_newPeriod, _newValidators);\n  }\n\n  /**\n   * @dev Activate/Deactivate the validators from producing blocks, based on their in jail status and maintenance status.\n   *\n   * Requirements:\n   * - This method is called at the end of each epoch\n   *\n   * Emits the `BlockProducerSetUpdated` event.\n   * Emits the `BridgeOperatorSetUpdated` event.\n   *\n   */\n  function _revampRoles(uint256 _newPeriod, uint256 _nextEpoch, address[] memory currValidatorIds) private {\n    bool[] memory _maintainedList = IMaintenance(getContract(ContractType.MAINTENANCE)).checkManyMaintainedById(\n      currValidatorIds,\n      block.number + 1\n    );\n\n    for (uint _i; _i < currValidatorIds.length; ) {\n      address validatorId = currValidatorIds[_i];\n      bool emergencyExitRequested = block.timestamp <= _emergencyExitJailedTimestamp[validatorId];\n      bool isProducerBefore = _isBlockProducerById(validatorId);\n      bool isProducerAfter = !(_isJailedAtBlockById(validatorId, block.number + 1) ||\n        _maintainedList[_i] ||\n        emergencyExitRequested);\n\n      if (!isProducerBefore && isProducerAfter) {\n        _validatorMap[validatorId] = _validatorMap[validatorId].addFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      } else if (isProducerBefore && !isProducerAfter) {\n        _validatorMap[validatorId] = _validatorMap[validatorId].removeFlag(EnumFlags.ValidatorFlag.BlockProducer);\n      }\n\n      unchecked {\n        ++_i;\n      }\n    }\n    emit BlockProducerSetUpdated(_newPeriod, _nextEpoch, getBlockProducerIds());\n  }\n\n  /**\n   * @dev Override `CandidateManager-_isTrustedOrg`.\n   */\n  function _isTrustedOrg(address validatorId) internal view override returns (bool) {\n    return\n      IRoninTrustedOrganization(getContract(ContractType.RONIN_TRUSTED_ORGANIZATION)).getConsensusWeightById(\n        validatorId\n      ) > 0;\n  }\n}\n"
    },
    "contracts/ronin/validator/EmergencyExit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/RONTransferHelper.sol\";\nimport \"../../interfaces/IRoninGovernanceAdmin.sol\";\nimport \"../../interfaces/validator/IEmergencyExit.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\nimport \"./CandidateManagerCallback.sol\";\n\nabstract contract EmergencyExit is IEmergencyExit, RONTransferHelper, CandidateManagerCallback, CommonStorage {\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExitLockedAmount() external view returns (uint256) {\n    return _emergencyExitLockedAmount;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function emergencyExpiryDuration() external view returns (uint256) {\n    return _emergencyExpiryDuration;\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execRequestEmergencyExit(address cid, uint256 secLeftToRevoke) external onlyContract(ContractType.STAKING) {\n    EmergencyExitInfo storage _info = _exitInfo[cid];\n    if (_info.recyclingAt != 0) revert ErrAlreadyRequestedEmergencyExit();\n\n    uint256 revokingTimestamp = block.timestamp + secLeftToRevoke;\n    _setRevokingTimestamp(_candidateInfo[cid], revokingTimestamp);\n    _emergencyExitJailedTimestamp[cid] = revokingTimestamp;\n\n    uint256 deductedAmount = IStaking(msg.sender).execDeductStakingAmount(cid, _emergencyExitLockedAmount);\n    if (deductedAmount > 0) {\n      uint256 recyclingAt = block.timestamp + _emergencyExpiryDuration;\n      _lockedConsensusList.push(cid);\n      _info.lockedAmount = deductedAmount;\n      _info.recyclingAt = recyclingAt;\n      IRoninGovernanceAdmin(_getAdmin()).createEmergencyExitPoll(\n        cid,\n        _candidateInfo[cid].__shadowedTreasury,\n        block.timestamp,\n        recyclingAt\n      );\n    }\n    emit EmergencyExitRequested(cid, deductedAmount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExitLockedAmount(uint256 amount) external onlyAdmin {\n    _setEmergencyExitLockedAmount(amount);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function setEmergencyExpiryDuration(uint256 duration) external onlyAdmin {\n    _setEmergencyExpiryDuration(duration);\n  }\n\n  /**\n   * @inheritdoc IEmergencyExit\n   */\n  function execReleaseLockedFundForEmergencyExitRequest(address cid, address payable recipient) external onlyAdmin {\n    if (_exitInfo[cid].recyclingAt == 0) {\n      revert ErrLockedFundReleaseInfoNotFound(cid);\n    }\n\n    uint256 length = _lockedConsensusList.length;\n    uint256 index = length;\n\n    for (uint i; i < length; ) {\n      if (_lockedConsensusList[i] == cid) {\n        index = i;\n        break;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    // The locked amount might be recycled\n    if (index == length) {\n      revert ErrLockedFundMightBeRecycled(cid);\n    }\n\n    uint256 amount = _exitInfo[cid].lockedAmount;\n    if (amount > 0) {\n      delete _exitInfo[cid];\n      if (length > 1) {\n        _lockedConsensusList[index] = _lockedConsensusList[length - 1];\n      }\n      _lockedConsensusList.pop();\n\n      _lockedFundReleased[cid] = true;\n      if (_unsafeSendRONLimitGas(recipient, amount, DEFAULT_ADDITION_GAS)) {\n        emit EmergencyExitLockedFundReleased(cid, recipient, amount);\n        return;\n      }\n\n      emit EmergencyExitLockedFundReleasingFailed(cid, recipient, amount, address(this).balance);\n    }\n  }\n\n  /**\n   * @dev Tries to recycle the locked funds from emergency exit requests.\n   */\n  function _tryRecycleLockedFundsFromEmergencyExits() internal {\n    uint256 length = _lockedConsensusList.length;\n\n    uint256 i;\n    address addr;\n    EmergencyExitInfo storage _info;\n\n    while (i < length) {\n      addr = _lockedConsensusList[i];\n      _info = _exitInfo[addr];\n\n      if (_info.recyclingAt <= block.timestamp) {\n        _totalDeprecatedReward += _info.lockedAmount;\n\n        delete _exitInfo[addr];\n        if (--length > 0) {\n          _lockedConsensusList[i] = _lockedConsensusList[length];\n        }\n        _lockedConsensusList.pop();\n        continue;\n      }\n\n      unchecked {\n        i++;\n      }\n    }\n  }\n\n  /**\n   * @dev Override `CandidateManager-_emergencyExitLockedFundReleased`.\n   */\n  function _emergencyExitLockedFundReleased(address cid) internal virtual override returns (bool) {\n    return _lockedFundReleased[cid];\n  }\n\n  /**\n   * @dev Override `CandidateManager-_removeCandidate`.\n   */\n  function _removeCandidate(address cid) internal override {\n    delete _lockedFundReleased[cid];\n    super._removeCandidate(cid);\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view virtual override(CandidateManager, CommonStorage) returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(\n    TConsensus[] memory consensusAddrs\n  ) internal view virtual override(CandidateManager, CommonStorage) returns (address[] memory);\n\n  /// @dev See {RoninValidatorSet-__cid2cssBatch}\n  function __cid2cssBatch(\n    address[] memory cids\n  ) internal view virtual override(CandidateManager, ValidatorInfoStorageV2) returns (TConsensus[] memory);\n\n  /**\n   * @dev See `setEmergencyExitLockedAmount.\n   */\n  function _setEmergencyExitLockedAmount(uint256 amount) internal {\n    _emergencyExitLockedAmount = amount;\n    emit EmergencyExitLockedAmountUpdated(amount);\n  }\n\n  /**\n   * @dev See `setEmergencyExpiryDuration`.\n   */\n  function _setEmergencyExpiryDuration(uint256 duration) internal {\n    _emergencyExpiryDuration = duration;\n    emit EmergencyExpiryDurationUpdated(duration);\n  }\n}\n"
    },
    "contracts/ronin/validator/RoninValidatorSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\nimport \"../../interfaces/validator/IRoninValidatorSet.sol\";\nimport \"./CoinbaseExecution.sol\";\nimport \"./SlashingExecution.sol\";\n\ncontract RoninValidatorSet is Initializable, CoinbaseExecution, SlashingExecution {\n  constructor() {\n    _disableInitializers();\n  }\n\n  fallback() external payable {\n    _fallback();\n  }\n\n  receive() external payable {\n    _fallback();\n  }\n\n  /**\n   * @dev Initializes the contract storage.\n   */\n  function initialize(\n    address __slashIndicatorContract,\n    address __stakingContract,\n    address __stakingVestingContract,\n    address __maintenanceContract,\n    address __roninTrustedOrganizationContract,\n    address /* __bridgeTrackingContract */,\n    uint256 __maxValidatorNumber,\n    uint256 __maxValidatorCandidate,\n    uint256 __maxPrioritizedValidatorNumber,\n    uint256 __minEffectiveDaysOnwards,\n    uint256 __numberOfBlocksInEpoch,\n    // __emergencyExitConfigs[0]: emergencyExitLockedAmount\n    // __emergencyExitConfigs[1]: emergencyExpiryDuration\n    uint256[2] calldata __emergencyExitConfigs\n  ) external initializer {\n    _setContract(ContractType.SLASH_INDICATOR, __slashIndicatorContract);\n    _setContract(ContractType.STAKING, __stakingContract);\n    _setContract(ContractType.STAKING_VESTING, __stakingVestingContract);\n    _setContract(ContractType.MAINTENANCE, __maintenanceContract);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, __roninTrustedOrganizationContract);\n\n    _setMaxValidatorNumber(__maxValidatorNumber);\n    _setMaxValidatorCandidate(__maxValidatorCandidate);\n    _setMaxPrioritizedValidatorNumber(__maxPrioritizedValidatorNumber);\n    _setMinEffectiveDaysOnwards(__minEffectiveDaysOnwards);\n    _setEmergencyExitLockedAmount(__emergencyExitConfigs[0]);\n    _setEmergencyExpiryDuration(__emergencyExitConfigs[1]);\n    _numberOfBlocksInEpoch = __numberOfBlocksInEpoch;\n  }\n\n  function initializeV2() external reinitializer(2) {\n    _setContract(ContractType.STAKING, ______deprecatedStakingContract);\n    _setContract(ContractType.MAINTENANCE, ______deprecatedMaintenance);\n    _setContract(ContractType.SLASH_INDICATOR, ______deprecatedSlashIndicator);\n    _setContract(ContractType.STAKING_VESTING, ______deprecatedStakingVesting);\n    _setContract(ContractType.RONIN_TRUSTED_ORGANIZATION, ______deprecatedTrustedOrg);\n\n    delete ______deprecatedStakingContract;\n    delete ______deprecatedMaintenance;\n    delete ______deprecatedSlashIndicator;\n    delete ______deprecatedStakingVesting;\n    delete ______deprecatedBridgeTracking;\n    delete ______deprecatedTrustedOrg;\n  }\n\n  function initializeV3(address fastFinalityTrackingContract) external reinitializer(3) {\n    _setContract(ContractType.FAST_FINALITY_TRACKING, fastFinalityTrackingContract);\n  }\n\n  function initializeV4(address profileContract) external reinitializer(4) {\n    _setContract(ContractType.PROFILE, profileContract);\n  }\n\n  /**\n   * @dev Only receives RON from staking vesting contract (for topping up bonus), and from staking contract (for transferring\n   * deducting amount on slashing).\n   */\n  function _fallback() internal view {\n    if (msg.sender != getContract(ContractType.STAKING_VESTING) && msg.sender != getContract(ContractType.STAKING)) {\n      revert ErrUnauthorizedReceiveRON();\n    }\n  }\n\n  /**\n   * @dev Convert consensus address to corresponding id from the Profile contract.\n   */\n  function __css2cid(TConsensus consensusAddr) internal view override(EmergencyExit, CommonStorage) returns (address) {\n    return IProfile(getContract(ContractType.PROFILE)).getConsensus2Id(consensusAddr);\n  }\n\n  /**\n   * @dev Convert many consensus addresses to corresponding ids from the Profile contract.\n   */\n  function __css2cidBatch(\n    TConsensus[] memory consensusAddrs\n  ) internal view override(EmergencyExit, CommonStorage) returns (address[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyConsensus2Id(consensusAddrs);\n  }\n\n  /**\n   * @dev Convert many id to corresponding consensus addresses from the Profile contract.\n   */\n  function __cid2cssBatch(\n    address[] memory cids\n  ) internal view override(EmergencyExit, ValidatorInfoStorageV2) returns (TConsensus[] memory) {\n    return IProfile(getContract(ContractType.PROFILE)).getManyId2Consensus(cids);\n  }\n}\n"
    },
    "contracts/ronin/validator/SlashingExecution.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../extensions/collections/HasContracts.sol\";\nimport \"../../interfaces/validator/ISlashingExecution.sol\";\nimport \"../../interfaces/staking/IStaking.sol\";\nimport \"../../libraries/Math.sol\";\nimport { HasSlashIndicatorDeprecated, HasStakingDeprecated } from \"../../utils/DeprecatedSlots.sol\";\nimport \"./storage-fragments/CommonStorage.sol\";\n\nabstract contract SlashingExecution is\n  ISlashingExecution,\n  HasContracts,\n  HasSlashIndicatorDeprecated,\n  HasStakingDeprecated,\n  CommonStorage\n{\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execSlash(\n    address validatorId,\n    uint256 newJailedUntil,\n    uint256 slashAmount,\n    bool cannotBailout\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    uint256 period = currentPeriod();\n    _miningRewardDeprecatedAtPeriod[validatorId][period] = true;\n\n    _totalDeprecatedReward += _miningReward[validatorId] + _delegatingReward[validatorId];\n\n    delete _miningReward[validatorId];\n    delete _delegatingReward[validatorId];\n\n    _blockProducerJailedBlock[validatorId] = Math.max(newJailedUntil, _blockProducerJailedBlock[validatorId]);\n\n    if (slashAmount > 0) {\n      uint256 _actualAmount = IStaking(getContract(ContractType.STAKING)).execDeductStakingAmount(\n        validatorId,\n        slashAmount\n      );\n      _totalDeprecatedReward += _actualAmount;\n    }\n\n    if (cannotBailout) {\n      _cannotBailoutUntilBlock[validatorId] = Math.max(newJailedUntil, _cannotBailoutUntilBlock[validatorId]);\n    }\n\n    emit ValidatorPunished(validatorId, period, _blockProducerJailedBlock[validatorId], slashAmount, true, false);\n  }\n\n  /**\n   * @inheritdoc ISlashingExecution\n   */\n  function execBailOut(\n    address validatorId,\n    uint256 period\n  ) external override onlyContract(ContractType.SLASH_INDICATOR) {\n    if (block.number <= _cannotBailoutUntilBlock[validatorId]) revert ErrCannotBailout(validatorId);\n\n    // Note: Removing rewards of validator in `bailOut` function is not needed, since the rewards have been\n    // removed previously in the `slash` function.\n    _miningRewardBailoutCutOffAtPeriod[validatorId][period] = true;\n    _miningRewardDeprecatedAtPeriod[validatorId][period] = false;\n    _blockProducerJailedBlock[validatorId] = block.number - 1;\n\n    emit ValidatorUnjailed(validatorId, period);\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/CommonStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/ICommonInfo.sol\";\nimport \"./JailingStorage.sol\";\nimport \"./TimingStorage.sol\";\nimport \"./ValidatorInfoStorageV2.sol\";\n\nabstract contract CommonStorage is ICommonInfo, TimingStorage, JailingStorage, ValidatorInfoStorageV2 {\n  /// @dev Mapping from consensus address => pending reward from producing block\n  mapping(address => uint256) internal _miningReward;\n  /// @dev Mapping from consensus address => pending reward from delegating\n  mapping(address => uint256) internal _delegatingReward;\n\n  /// @dev The total reward for fast finality\n  uint256 internal _totalFastFinalityReward;\n  /// @dev Mapping from consensus address => pending reward for fast finality\n  mapping(address => uint256) internal _fastFinalityReward;\n\n  /// @dev The deprecated reward that has not been withdrawn by admin\n  uint256 internal _totalDeprecatedReward;\n\n  /// @dev The amount of RON to lock from a consensus address.\n  uint256 internal _emergencyExitLockedAmount;\n  /// @dev The duration that an emergency request is expired and the fund will be recycled.\n  uint256 internal _emergencyExpiryDuration;\n  /// @dev The address list of consensus addresses that being locked fund.\n  address[] internal _lockedConsensusList;\n  /// @dev Mapping from consensus => request exist info\n  mapping(address => EmergencyExitInfo) internal _exitInfo;\n  /// @dev Mapping from consensus => flag indicating whether the locked fund is released\n  mapping(address => bool) internal _lockedFundReleased;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[44] private ______gap;\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function getEmergencyExitInfo(TConsensus consensus) external view override returns (EmergencyExitInfo memory _info) {\n    _info = _exitInfo[__css2cid(consensus)];\n    if (_info.recyclingAt == 0) revert NonExistentRecyclingInfo();\n  }\n\n  /**\n   * @inheritdoc ICommonInfo\n   */\n  function totalDeprecatedReward() external view override returns (uint256) {\n    return _totalDeprecatedReward;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(\n    uint256 _block\n  ) public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.epochOf(_block);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override(ITimingInfo, JailingStorage, TimingStorage) returns (uint256) {\n    return TimingStorage.currentPeriod();\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(\n    TConsensus consensusAddr\n  ) internal view virtual override(JailingStorage, ValidatorInfoStorageV2) returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(\n    TConsensus[] memory consensusAddrs\n  ) internal view virtual override(JailingStorage, ValidatorInfoStorageV2) returns (address[] memory);\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/JailingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../interfaces/validator/info-fragments/IJailingInfo.sol\";\n\nabstract contract JailingStorage is IJailingInfo {\n  /// @dev Mapping from candidate id => period number => block producer has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardDeprecatedAtPeriod;\n  /// @dev Mapping from candidate id => period number => whether the block producer get cut off reward, due to bailout.\n  mapping(address => mapping(uint256 => bool)) internal _miningRewardBailoutCutOffAtPeriod;\n  /// @dev Mapping from candidate id => period number => block operator has no pending reward.\n  mapping(address => mapping(uint256 => bool)) internal ______deprecatedBridgeRewardDeprecatedAtPeriod;\n\n  /// @dev Mapping from candidate id => the last block that the block producer is jailed.\n  mapping(address => uint256) internal _blockProducerJailedBlock;\n  /// @dev Mapping from candidate id => the last timestamp that the bridge operator is jailed.\n  mapping(address => uint256) internal _emergencyExitJailedTimestamp;\n  /// @dev Mapping from candidate id => the last block that the block producer cannot bailout.\n  mapping(address => uint256) internal _cannotBailoutUntilBlock;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[48] private ______gap;\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailed(TConsensus consensus) external view override returns (bool) {\n    address candidateId = __css2cid(consensus);\n    return _isJailedAtBlockById(candidateId, block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkJailedAtBlock(TConsensus addr, uint256 blockNum) external view override returns (bool) {\n    address candidateId = __css2cid(addr);\n    return _isJailedAtBlockById(candidateId, blockNum);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeft(\n    TConsensus consensus\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    return _getJailedTimeLeftAtBlockById(__css2cid(consensus), block.number);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function getJailedTimeLeftAtBlock(\n    TConsensus consensus,\n    uint256 _blockNum\n  ) external view override returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    return _getJailedTimeLeftAtBlockById(__css2cid(consensus), _blockNum);\n  }\n\n  function _getJailedTimeLeftAtBlockById(\n    address candidateId,\n    uint256 blockNum\n  ) internal view returns (bool isJailed_, uint256 blockLeft_, uint256 epochLeft_) {\n    uint256 jailedBlock = _blockProducerJailedBlock[candidateId];\n    if (jailedBlock < blockNum) {\n      return (false, 0, 0);\n    }\n\n    isJailed_ = true;\n    blockLeft_ = jailedBlock - blockNum + 1;\n    epochLeft_ = epochOf(jailedBlock) - epochOf(blockNum) + 1;\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkManyJailed(TConsensus[] calldata consensusList) external view override returns (bool[] memory) {\n    return _checkManyJailedById(__css2cidBatch(consensusList));\n  }\n\n  function checkManyJailedById(address[] calldata candidateIds) external view override returns (bool[] memory) {\n    return _checkManyJailedById(candidateIds);\n  }\n\n  function _checkManyJailedById(address[] memory candidateIds) internal view returns (bool[] memory result) {\n    result = new bool[](candidateIds.length);\n    for (uint256 i; i < candidateIds.length; ) {\n      result[i] = _isJailedById(candidateIds[i]);\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecated(TConsensus consensus) external view override returns (bool) {\n    uint256 period = currentPeriod();\n    return _miningRewardDeprecatedById(__css2cid(consensus), period);\n  }\n\n  /**\n   * @inheritdoc IJailingInfo\n   */\n  function checkMiningRewardDeprecatedAtPeriod(\n    TConsensus consensus,\n    uint256 period\n  ) external view override returns (bool) {\n    return _miningRewardDeprecatedById(__css2cid(consensus), period);\n  }\n\n  /**\n   * @dev See `ITimingInfo-epochOf`\n   */\n  function epochOf(uint256 _block) public view virtual returns (uint256);\n\n  /**\n   * @dev See `ITimingInfo-currentPeriod`\n   */\n  function currentPeriod() public view virtual returns (uint256);\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) during the current period.\n   */\n  function _isJailedById(address validatorId) internal view returns (bool) {\n    return _isJailedAtBlockById(validatorId, block.number);\n  }\n\n  /**\n   * @dev Returns whether the reward of the validator is put in jail (cannot join the set of validators) at a specific block.\n   */\n  function _isJailedAtBlockById(address validatorId, uint256 blockNum) internal view returns (bool) {\n    return blockNum <= _blockProducerJailedBlock[validatorId];\n  }\n\n  /**\n   * @dev Returns whether the block producer has no pending reward in that period.\n   */\n  function _miningRewardDeprecatedById(address validatorId, uint256 period) internal view returns (bool) {\n    return _miningRewardDeprecatedAtPeriod[validatorId][period];\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/TimingStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../extensions/consumers/GlobalConfigConsumer.sol\";\nimport \"../../../interfaces/validator/info-fragments/ITimingInfo.sol\";\n\nabstract contract TimingStorage is ITimingInfo, GlobalConfigConsumer {\n  /// @dev The number of blocks in a epoch\n  uint256 internal _numberOfBlocksInEpoch;\n  /// @dev The last updated block\n  uint256 internal _lastUpdatedBlock;\n  /// @dev The last updated period\n  uint256 internal _lastUpdatedPeriod;\n  /// @dev The starting block of the last updated period\n  uint256 internal _currentPeriodStartAtBlock;\n\n  /// @dev Mapping from epoch index => period index\n  mapping(uint256 => uint256) internal _periodOf;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[49] private ______gap;\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function getLastUpdatedBlock() external view override returns (uint256) {\n    return _lastUpdatedBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochOf(uint256 _block) public view virtual override returns (uint256) {\n    return _block / _numberOfBlocksInEpoch + 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function tryGetPeriodOfEpoch(uint256 _epoch) external view returns (bool _filled, uint256 _periodNumber) {\n    return (_epoch <= epochOf(block.number) || _periodOf[_epoch] > 0, _periodOf[_epoch]);\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function isPeriodEnding() external view override returns (bool) {\n    return _isPeriodEnding(_computePeriod(block.timestamp));\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function epochEndingAt(uint256 _block) public view virtual override returns (bool) {\n    return _block % _numberOfBlocksInEpoch == _numberOfBlocksInEpoch - 1;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriod() public view virtual override returns (uint256) {\n    return _lastUpdatedPeriod;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function currentPeriodStartAtBlock() public view override returns (uint256) {\n    return _currentPeriodStartAtBlock;\n  }\n\n  /**\n   * @inheritdoc ITimingInfo\n   */\n  function numberOfBlocksInEpoch() public view virtual override returns (uint256 _numberOfBlocks) {\n    return _numberOfBlocksInEpoch;\n  }\n\n  /**\n   * @dev See `ITimingInfo-isPeriodEnding`\n   */\n  function _isPeriodEnding(uint256 _newPeriod) internal view virtual returns (bool) {\n    return _newPeriod > _lastUpdatedPeriod;\n  }\n\n  /**\n   * @dev Returns the calculated period.\n   */\n  function _computePeriod(uint256 _timestamp) internal pure returns (uint256) {\n    return _timestamp / PERIOD_DURATION;\n  }\n}\n"
    },
    "contracts/ronin/validator/storage-fragments/ValidatorInfoStorageV2.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\nimport \"../../../libraries/EnumFlags.sol\";\nimport { HasTrustedOrgDeprecated } from \"../../../utils/DeprecatedSlots.sol\";\nimport \"../../../extensions/collections/HasContracts.sol\";\nimport \"../../../interfaces/validator/info-fragments/IValidatorInfoV2.sol\";\nimport \"../../../interfaces/IProfile.sol\";\nimport { TConsensus } from \"../../../udvts/Types.sol\";\n\nabstract contract ValidatorInfoStorageV2 is IValidatorInfoV2, HasContracts, HasTrustedOrgDeprecated {\n  using EnumFlags for EnumFlags.ValidatorFlag;\n\n  /// @dev The maximum number of validator.\n  uint256 internal _maxValidatorNumber;\n\n  /// @dev The total of validators\n  uint256 internal _validatorCount;\n  /// @dev Mapping from validator index => validator id address\n  mapping(uint256 => address) internal _validatorIds;\n  /// @dev Mapping from validator id => flag indicating the validator ability: producing block, operating bridge\n  mapping(address => EnumFlags.ValidatorFlag) internal _validatorMap;\n  /// @dev The number of slot that is reserved for prioritized validators\n  uint256 internal _maxPrioritizedValidatorNumber;\n\n  /**\n   * @dev This empty reserved space is put in place to allow future versions to add new\n   * variables without shifting down storage in the inheritance chain.\n   */\n  uint256[50] private ______gap;\n\n  function validatorCount() external view returns (uint256) {\n    return _validatorCount;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getValidators() public view override returns (TConsensus[] memory consensusList) {\n    return __cid2cssBatch(getValidatorIds());\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getValidatorIds() public view override returns (address[] memory cids) {\n    cids = new address[](_validatorCount);\n    address iValidator;\n    for (uint i; i < cids.length; ) {\n      iValidator = _validatorIds[i];\n      cids[i] = iValidator;\n\n      unchecked {\n        ++i;\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getBlockProducers() public view override returns (TConsensus[] memory consensusList) {\n    return __cid2cssBatch(getBlockProducerIds());\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function getBlockProducerIds() public view override returns (address[] memory cids) {\n    cids = new address[](_validatorCount);\n    uint256 count = 0;\n    for (uint i; i < cids.length; ) {\n      address validatorId = _validatorIds[i];\n      if (_isBlockProducerById(validatorId)) {\n        cids[count++] = validatorId;\n      }\n\n      unchecked {\n        ++i;\n      }\n    }\n\n    assembly (\"memory-safe\") {\n      mstore(cids, count)\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function isBlockProducer(TConsensus consensusAddr) public view override returns (bool) {\n    return _isBlockProducerById(__css2cid(consensusAddr));\n  }\n\n  function _isBlockProducerById(address id) internal view returns (bool) {\n    return _validatorMap[id].hasFlag(EnumFlags.ValidatorFlag.BlockProducer);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function totalBlockProducer() external view returns (uint256 total) {\n    unchecked {\n      for (uint i; i < _validatorCount; i++) {\n        if (_isBlockProducerById(_validatorIds[i])) {\n          total++;\n        }\n      }\n    }\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function maxValidatorNumber() external view override returns (uint256 _maximumValidatorNumber) {\n    return _maxValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function maxPrioritizedValidatorNumber() external view override returns (uint256 _maximumPrioritizedValidatorNumber) {\n    return _maxPrioritizedValidatorNumber;\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function setMaxValidatorNumber(uint256 _max) external override onlyAdmin {\n    _setMaxValidatorNumber(_max);\n  }\n\n  /**\n   * @inheritdoc IValidatorInfoV2\n   */\n  function setMaxPrioritizedValidatorNumber(uint256 _number) external override onlyAdmin {\n    _setMaxPrioritizedValidatorNumber(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfoV2-setMaxValidatorNumber`\n   */\n  function _setMaxValidatorNumber(uint256 _number) internal {\n    _maxValidatorNumber = _number;\n    emit MaxValidatorNumberUpdated(_number);\n  }\n\n  /**\n   * @dev See `IValidatorInfoV2-setMaxPrioritizedValidatorNumber`\n   */\n  function _setMaxPrioritizedValidatorNumber(uint256 _number) internal {\n    if (_number > _maxValidatorNumber) revert ErrInvalidMaxPrioritizedValidatorNumber();\n    _maxPrioritizedValidatorNumber = _number;\n    emit MaxPrioritizedValidatorNumberUpdated(_number);\n  }\n\n  /// @dev See {RoninValidatorSet-__css2cid}\n  function __css2cid(TConsensus consensusAddr) internal view virtual returns (address);\n\n  /// @dev See {RoninValidatorSet-__css2cidBatch}\n  function __css2cidBatch(TConsensus[] memory consensusAddrs) internal view virtual returns (address[] memory);\n\n  /// @dev See {RoninValidatorSet-__cid2cssBatch}\n  function __cid2cssBatch(address[] memory cids) internal view virtual returns (TConsensus[] memory);\n}\n"
    },
    "contracts/udvts/Types.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.19;\n\ntype TPoolId is address;\ntype TConsensus is address;\n\nusing { TPoolIdEq as == } for TPoolId global;\nusing { TConsensusEq as == } for TConsensus global;\n\nfunction TPoolIdEq(TPoolId a, TPoolId b) pure returns (bool) {\n  return TPoolId.unwrap(a) == TPoolId.unwrap(b);\n}\n\nfunction TConsensusEq(TConsensus a, TConsensus b) pure returns (bool) {\n  return TConsensus.unwrap(a) == TConsensus.unwrap(b);\n}\n"
    },
    "contracts/utils/CommonErrors.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { ContractType } from \"./ContractType.sol\";\nimport { RoleAccess } from \"./RoleAccess.sol\";\n\nerror ErrSyncTooFarPeriod(uint256 period, uint256 latestRewardedPeriod);\n\n/**\n * @dev Error raised when a bridge operator update operation fails.\n * @param bridgeOperator The address of the bridge operator that failed to update.\n */\nerror ErrBridgeOperatorUpdateFailed(address bridgeOperator);\n\n/**\n * @dev Error thrown when an address is expected to be an already created externally owned account (EOA).\n * This error indicates that the provided address is invalid for certain contract operations that require already created EOA.\n */\nerror ErrAddressIsNotCreatedEOA(address addr, bytes32 codehash);\n\n/**\n * @dev Error thrown when attempting to add a bridge operator that already exists in the contract.\n * This error indicates that the provided bridge operator address is already registered as a bridge operator in the contract.\n */\nerror ErrBridgeOperatorAlreadyExisted(address bridgeOperator);\n\n/**\n * @dev The error indicating an unsupported interface.\n * @param interfaceId The bytes4 interface identifier that is not supported.\n * @param addr The address where the unsupported interface was encountered.\n */\nerror ErrUnsupportedInterface(bytes4 interfaceId, address addr);\n\n/**\n * @dev Error thrown when the return data from a callback function is invalid.\n * @param callbackFnSig The signature of the callback function that returned invalid data.\n * @param register The address of the register where the callback function was invoked.\n * @param returnData The invalid return data received from the callback function.\n */\nerror ErrInvalidReturnData(bytes4 callbackFnSig, address register, bytes returnData);\n\n/**\n * @dev Error of set to non-contract.\n */\nerror ErrZeroCodeContract(address addr);\n\n/**\n * @dev Error indicating that arguments are invalid.\n */\nerror ErrInvalidArguments(bytes4 msgSig);\n\n/**\n * @dev Error indicating that given address is null when it should not.\n */\nerror ErrZeroAddress(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the provided threshold is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that the invalid threshold applies to.\n */\nerror ErrInvalidThreshold(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a function can only be called by the contract itself.\n * @param msgSig The function signature (bytes4) that can only be called by the contract itself.\n */\nerror ErrOnlySelfCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n * @param expectedRole The role required to perform the function.\n */\nerror ErrUnauthorized(bytes4 msgSig, RoleAccess expectedRole);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4) that the caller is unauthorized to perform.\n */\nerror ErrUnauthorizedCall(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the caller is unauthorized to perform a specific function.\n * @param msgSig The function signature (bytes4).\n * @param expectedContractType The contract type required to perform the function.\n * @param actual The actual address that called to the function.\n */\nerror ErrUnexpectedInternalCall(bytes4 msgSig, ContractType expectedContractType, address actual);\n\n/**\n * @dev Error indicating that an array is empty when it should contain elements.\n */\nerror ErrEmptyArray();\n\n/**\n * @dev Error indicating a mismatch in the length of input parameters or arrays for a specific function.\n * @param msgSig The function signature (bytes4) that has a length mismatch.\n */\nerror ErrLengthMismatch(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a proxy call to an external contract has failed.\n * @param msgSig The function signature (bytes4) of the proxy call that failed.\n * @param extCallSig The function signature (bytes4) of the external contract call that failed.\n */\nerror ErrProxyCallFailed(bytes4 msgSig, bytes4 extCallSig);\n\n/**\n * @dev Error indicating that a function tried to call a precompiled contract that is not allowed.\n * @param msgSig The function signature (bytes4) that attempted to call a precompiled contract.\n */\nerror ErrCallPrecompiled(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a native token transfer has failed.\n * @param msgSig The function signature (bytes4) of the token transfer that failed.\n */\nerror ErrNativeTransferFailed(bytes4 msgSig);\n\n/**\n * @dev Error indicating that an order is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid order.\n */\nerror ErrInvalidOrder(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the chain ID is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid chain ID.\n * @param actual Current chain ID that executing function.\n * @param expected Expected chain ID required for the tx to success.\n */\nerror ErrInvalidChainId(bytes4 msgSig, uint256 actual, uint256 expected);\n\n/**\n * @dev Error indicating that a vote type is not supported.\n * @param msgSig The function signature (bytes4) of the operation that encountered an unsupported vote type.\n */\nerror ErrUnsupportedVoteType(bytes4 msgSig);\n\n/**\n * @dev Error indicating that the proposal nonce is invalid.\n * @param msgSig The function signature (bytes4) of the operation that encountered an invalid proposal nonce.\n */\nerror ErrInvalidProposalNonce(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a voter has already voted.\n * @param voter The address of the voter who has already voted.\n */\nerror ErrAlreadyVoted(address voter);\n\n/**\n * @dev Error indicating that a signature is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid signature.\n */\nerror ErrInvalidSignatures(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a relay call has failed.\n * @param msgSig The function signature (bytes4) of the relay call that failed.\n */\nerror ErrRelayFailed(bytes4 msgSig);\n/**\n * @dev Error indicating that a vote weight is invalid for a specific function signature.\n * @param msgSig The function signature (bytes4) that encountered an invalid vote weight.\n */\nerror ErrInvalidVoteWeight(bytes4 msgSig);\n\n/**\n * @dev Error indicating that a query was made for an outdated bridge operator set.\n */\nerror ErrQueryForOutdatedBridgeOperatorSet();\n\n/**\n * @dev Error indicating that a request is invalid.\n */\nerror ErrInvalidRequest();\n\n/**\n * @dev Error indicating that a token standard is invalid.\n */\nerror ErrInvalidTokenStandard();\n\n/**\n * @dev Error indicating that a token is not supported.\n */\nerror ErrUnsupportedToken();\n\n/**\n * @dev Error indicating that a receipt kind is invalid.\n */\nerror ErrInvalidReceiptKind();\n\n/**\n * @dev Error indicating that a receipt is invalid.\n */\nerror ErrInvalidReceipt();\n\n/**\n * @dev Error indicating that an address is not payable.\n */\nerror ErrNonpayableAddress(address);\n\n/**\n * @dev Error indicating that the period is already processed, i.e. scattered reward.\n */\nerror ErrPeriodAlreadyProcessed(uint256 requestingPeriod, uint256 latestPeriod);\n\n/**\n * @dev Error thrown when an invalid vote hash is provided.\n */\nerror ErrInvalidVoteHash();\n\n/**\n * @dev Error thrown when querying for an empty vote.\n */\nerror ErrQueryForEmptyVote();\n\n/**\n * @dev Error thrown when querying for an expired vote.\n */\nerror ErrQueryForExpiredVote();\n\n/**\n * @dev Error thrown when querying for a non-existent vote.\n */\nerror ErrQueryForNonExistentVote();\n\n/**\n * @dev Error indicating that the method is only called once per block.\n */\nerror ErrOncePerBlock();\n\n/**\n * @dev Error of method caller must be coinbase\n */\nerror ErrCallerMustBeCoinbase();\n"
    },
    "contracts/utils/ContractType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum ContractType {\n  /*  0 */ UNKNOWN,\n  /*  1 */ PAUSE_ENFORCER,\n  /*  2 */ BRIDGE,\n  /*  3 */ BRIDGE_TRACKING,\n  /*  4 */ GOVERNANCE_ADMIN,\n  /*  5 */ MAINTENANCE,\n  /*  6 */ SLASH_INDICATOR,\n  /*  7 */ STAKING_VESTING,\n  /*  8 */ VALIDATOR,\n  /*  9 */ STAKING,\n  /* 10 */ RONIN_TRUSTED_ORGANIZATION,\n  /* 11 */ BRIDGE_MANAGER,\n  /* 12 */ BRIDGE_SLASH,\n  /* 13 */ BRIDGE_REWARD,\n  /* 14 */ FAST_FINALITY_TRACKING,\n  /* 15 */ PROFILE\n}\n"
    },
    "contracts/utils/DeprecatedSlots.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/**\n * @title Deprecated Contracts\n * @dev These abstract contracts are deprecated and should not be used in new implementations.\n * They provide functionality related to various aspects of a smart contract but have been marked\n * as deprecated to indicate that they are no longer actively maintained or recommended for use.\n * The purpose of these contracts is to preserve the slots for already deployed contracts.\n */\ncontract HasSlashIndicatorDeprecated {\n  /// @custom:deprecated Previously `_slashIndicatorContract` (non-zero value)\n  address internal ______deprecatedSlashIndicator;\n}\n\ncontract HasStakingVestingDeprecated {\n  /// @custom:deprecated Previously `_stakingVestingContract` (non-zero value)\n  address internal ______deprecatedStakingVesting;\n}\n\ncontract HasBridgeDeprecated {\n  /// @custom:deprecated Previously `_bridgeContract` (non-zero value)\n  address internal ______deprecatedBridge;\n}\n\ncontract HasValidatorDeprecated {\n  /// @custom:deprecated Previously `_validatorContract` (non-zero value)\n  address internal ______deprecatedValidator;\n}\n\ncontract HasStakingDeprecated {\n  /// @custom:deprecated Previously `_stakingContract` (non-zero value)\n  address internal ______deprecatedStakingContract;\n}\n\ncontract HasMaintenanceDeprecated {\n  /// @custom:deprecated Previously `_maintenanceContract` (non-zero value)\n  address internal ______deprecatedMaintenance;\n}\n\ncontract HasTrustedOrgDeprecated {\n  /// @custom:deprecated Previously `_trustedOrgContract` (non-zero value)\n  address internal ______deprecatedTrustedOrg;\n}\n\ncontract HasGovernanceAdminDeprecated {\n  /// @custom:deprecated Previously `_governanceAdminContract` (non-zero value)\n  address internal ______deprecatedGovernanceAdmin;\n}\n\ncontract HasBridgeTrackingDeprecated {\n  /// @custom:deprecated Previously `_bridgeTrackingContract` (non-zero value)\n  address internal ______deprecatedBridgeTracking;\n}\n"
    },
    "contracts/utils/IdentityGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport { AddressArrayUtils } from \"../libraries/AddressArrayUtils.sol\";\nimport { IERC165 } from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport { TransparentUpgradeableProxyV2 } from \"../extensions/TransparentUpgradeableProxyV2.sol\";\nimport { ErrAddressIsNotCreatedEOA, ErrZeroAddress, ErrOnlySelfCall, ErrZeroCodeContract, ErrUnsupportedInterface } from \"./CommonErrors.sol\";\n\nabstract contract IdentityGuard {\n  using AddressArrayUtils for address[];\n\n  /// @dev value is equal to keccak256(abi.encode())\n  /// @dev see: https://eips.ethereum.org/EIPS/eip-1052\n  bytes32 internal constant CREATED_ACCOUNT_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n  /**\n   * @dev Modifier to restrict functions to only be called by this contract.\n   * @dev Reverts if the caller is not this contract.\n   */\n  modifier onlySelfCall() virtual {\n    _requireSelfCall();\n    _;\n  }\n\n  /**\n   * @dev Modifier to ensure that the elements in the `arr` array are non-duplicates.\n   * It calls the internal `_checkDuplicate` function to perform the duplicate check.\n   *\n   * Requirements:\n   * - The elements in the `arr` array must not contain any duplicates.\n   */\n  modifier nonDuplicate(address[] memory arr) virtual {\n    _requireNonDuplicate(arr);\n    _;\n  }\n\n  /**\n   * @dev Internal method to check the method caller.\n   * @dev Reverts if the method caller is not this contract.\n   */\n  function _requireSelfCall() internal view virtual {\n    if (msg.sender != address(this)) revert ErrOnlySelfCall(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to check if a contract address has code.\n   * @param addr The address of the contract to check.\n   * @dev Throws an error if the contract address has no code.\n   */\n  function _requireHasCode(address addr) internal view {\n    if (addr.code.length == 0) revert ErrZeroCodeContract(addr);\n  }\n\n  /**\n   * @dev Checks if an address is zero and reverts if it is.\n   * @param addr The address to check.\n   */\n  function _requireNonZeroAddress(address addr) internal pure {\n    if (addr == address(0)) revert ErrZeroAddress(msg.sig);\n  }\n\n  /**\n   * @dev Check if arr is empty and revert if it is.\n   * Checks if an array contains any duplicate addresses and reverts if duplicates are found.\n   * @param arr The array of addresses to check.\n   */\n  function _requireNonDuplicate(address[] memory arr) internal pure {\n    if (arr.hasDuplicate()) revert AddressArrayUtils.ErrDuplicated(msg.sig);\n  }\n\n  /**\n   * @dev Internal function to require that the provided address is a created externally owned account (EOA).\n   * This internal function is used to ensure that the provided address is a valid externally owned account (EOA).\n   * It checks the codehash of the address against a predefined constant to confirm that the address is a created EOA.\n   * @notice This method only works with non-state EOA accounts\n   */\n  function _requireCreatedEOA(address addr) internal view {\n    _requireNonZeroAddress(addr);\n    bytes32 codehash = addr.codehash;\n    if (codehash != CREATED_ACCOUNT_HASH) revert ErrAddressIsNotCreatedEOA(addr, codehash);\n  }\n\n  /**\n   * @dev Internal function to require that the specified contract supports the given interface. This method handle in\n   * both case that the callee is either or not the proxy admin of the caller. If the contract does not support the\n   * interface `interfaceId` or EIP165, a revert with the corresponding error message is triggered.\n   *\n   * @param contractAddr The address of the contract to check for interface support.\n   * @param interfaceId The interface ID to check for support.\n   */\n  function _requireSupportsInterface(address contractAddr, bytes4 interfaceId) internal view {\n    bytes memory supportsInterfaceParams = abi.encodeCall(IERC165.supportsInterface, (interfaceId));\n    (bool success, bytes memory returnOrRevertData) = contractAddr.staticcall(supportsInterfaceParams);\n    if (!success) {\n      (success, returnOrRevertData) = contractAddr.staticcall(\n        abi.encodeCall(TransparentUpgradeableProxyV2.functionDelegateCall, (supportsInterfaceParams))\n      );\n      if (!success) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n    }\n    if (!abi.decode(returnOrRevertData, (bool))) revert ErrUnsupportedInterface(interfaceId, contractAddr);\n  }\n}\n"
    },
    "contracts/utils/RoleAccess.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nenum RoleAccess {\n  /* 0 */ UNKNOWN,\n  /* 1 */ ADMIN,\n  /* 2 */ COINBASE,\n  /* 3 */ GOVERNOR,\n  /* 4 */ CANDIDATE_ADMIN,\n  /* 5 */ WITHDRAWAL_MIGRATOR,\n  /* 6 */ __DEPRECATED_BRIDGE_OPERATOR,\n  /* 7 */ BLOCK_PRODUCER,\n  /* 8 */ VALIDATOR_CANDIDATE,\n  /* 9 */ CONSENSUS,\n  /* 10 */ TREASURY\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}